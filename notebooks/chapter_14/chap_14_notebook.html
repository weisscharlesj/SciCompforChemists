
<!DOCTYPE html>


<html lang="en" data-content_root="../../" data-theme="light">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Chapter 14: Optimization and Root Finding &#8212; Scientific Computing for Chemists with Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "light";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/chapter_14/chap_14_notebook';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Chapter 15: Cheminformatics with RDKit" href="../chapter_15/chap_15_notebook.html" />
    <link rel="prev" title="Chapter 13: Machine Learning using Scikit-Learn" href="../chapter_13/chap_13_notebook.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="light">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../introduction/intro.html">
  
  
  
  
  
    
    
    
    <img src="../../_static/logo.svg" class="logo__image only-light" alt="Scientific Computing for Chemists with Python - Home"/>
    <img src="../../_static/logo.svg" class="logo__image only-dark pst-js-only" alt="Scientific Computing for Chemists with Python - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../introduction/intro.html">
                    Scientific Computing for Chemists with Python
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Basic Scientific Computing Skills</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_00/chap_00_notebook.html">Chapter 0: Python &amp; Jupyter Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_01/chap_01_notebook.html">Chapter 1: Basic Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_02/chap_02_notebook.html">Chapter 2: Intermediate Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_03/chap_03_notebook.html">Chapter 3: Plotting with Matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_04/chap_04_notebook.html">Chapter 4: NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_05/chap_05_notebook.html">Chapter 5: Pandas</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Advanced Topics &amp; Applications</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_06/chap_06_notebook.html">Chapter 6: Signal &amp; Noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_07/chap_07_notebook.html">Chapter 7: Image Processing &amp; Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_08/chap_08_notebook.html">Chapter 8: Mathematics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_09/chap_09_notebook.html">Chapter 9: Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_10/chap_10_notebook.html">Chapter 10: Plotting with Seaborn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_11/chap_11_notebook.html">Chapter 11: Plotting with Altair</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_12/chap_12_notebook.html">Chapter 12: Nuclear Magnetic Resonance with nmrglue and nmrsim</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_13/chap_13_notebook.html">Chapter 13: Machine Learning using Scikit-Learn</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 14: Optimization and Root Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_15/chap_15_notebook.html">Chapter 15: Cheminformatics with RDKit</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_16/chap_16_notebook.html">Chapter 16: Bioinformatics with Biopython and Nglview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_17/chap_17_notebook.html">Chapter 17: Command Line &amp; Spyder</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Back Matter</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../appendix_00/appendix_00_notebook.html">Appendix 0: Ipython Widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix_01/appendix_01_notebook.html">Appendix 1: Remote Requests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix_02/appendix_02_notebook.html">Appendix 2: Visualizing Atomic Orbitals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix_03/appendix_03_notebook.html">Appendix 3: Uncertainty Propagation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../appendix_04/appendix_04_notebook.html">Appendix 4: Regular Expressions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/weisscharlesj/SciCompforChemists" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/weisscharlesj/SciCompforChemists/issues/new?title=Issue%20on%20page%20%2Fnotebooks/chapter_14/chap_14_notebook.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/chapter_14/chap_14_notebook.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 14: Optimization and Root Finding</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimization">14.1 Minimization</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#univariant-minimization">14.1.1 Univariant Minimization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimization-for-maximization">14.1.2 Minimization for Maximization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multivarient-minimization">14.1.3 Multivarient Minimization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fitting-equations-to-data">14.2 Fitting Equations to Data</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-equations">14.2.1 Linear Equations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nonlinear-regression">14.2.2 Nonlinear Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mixed-analyte-example">14.2.3 Mixed Analyte Example</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#root-finding">14.3 Root Finding</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further Reading</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-14-optimization-and-root-finding">
<span id="id1"></span><span id="index-1"></span><span id="index-0"></span><h1>Chapter 14: Optimization and Root Finding<a class="headerlink" href="#chapter-14-optimization-and-root-finding" title="Link to this heading">#</a></h1>
<p><em>Optimization</em> is the process of improving something to the extent that it cannot be reasonably improved any further. This often involves maximizing desirable attributes and/or minimizing those that are undesirable, so finding the maximum and minimum are common optimization goals. While you may or may not have previously worked <em>directly</em> with optimization, you almost certainly have used it as part of a larger application or task such as energy minimization of a molecule, regression analysis, or a number of machine learning algorithms.</p>
<p>In optimization tasks, we often find ourselves searching for the maximum or minimum of a given mathematical function. If we, for example, seek to minimize a function <span class="math notranslate nohighlight">\(f(a,b)\)</span>, our goal is to find values for input variables <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> to generate the smallest possible output from the function <span class="math notranslate nohighlight">\(f\)</span>. One approach is to manually try different input values until you get the smallest possible output, but this kind of tedious and time-consuming task is best left to computers. The <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module contains a number of tools for performing optimizations of mathematical functions. The goal of this chapter is to introduce the <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module and apply it to chemical applications. This chapter does not go into the deeper theory behind optimization, such as specific algorithms. For those interested in some of the deeper theory of optimization, see the <a class="reference internal" href="#fr14"><span class="std std-ref">Further Reading</span></a> section.</p>
<p>Before we begin, we first need to address how we measure what is “best”? For this, we use a <em>cost function</em>, also known as an <em>objective function</em> or <em>criterion</em>, which is a mathematical function that takes in features and returns a value that is a measure of “goodness.” If we were a company that is trying to maximize our profits, the objective function would likely be some mathematical equation that calculates our net profit. Optimization of a molecule’s conformation involves minimizing the energy, so the objective function here is the function that calculates the energy of the molecule based on the attributes like bond angles and lengths. In the examples below, each of the <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> functions takes as its first argument an objective function in the form of a Python function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">obj_func</span><span class="p">)</span>
</pre></div>
</div>
<p>The examples in this chapter assume the following imports from NumPy, SciPy, pandas, and matplotlib.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<section id="minimization">
<span id="id2"></span><span id="index-2"></span><h2>14.1 Minimization<a class="headerlink" href="#minimization" title="Link to this heading">#</a></h2>
<p>The first task we will look at is minimization, and for this, <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> has two related functions <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize()</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize_scalar()</span></code>. Both functions minimize the provided function, but the difference is in the number of independent variables that the objective function takes. A function with only one independent variable, <span class="math notranslate nohighlight">\(f(a)\)</span>, is known as <em>univariant</em> while a function that takes multiple independent variables, <span class="math notranslate nohighlight">\(f(a,b,...)\)</span>, is known as <em>multivariant</em>. The <code class="docutils literal notranslate"><span class="pre">minimize()</span></code> function can minimize either multivariant and univariant functions while <code class="docutils literal notranslate"><span class="pre">minimize_scalar()</span></code> can only accept univariant objective functions.</p>
<section id="univariant-minimization">
<span id="id3"></span><h3>14.1.1 Univariant Minimization<a class="headerlink" href="#univariant-minimization" title="Link to this heading">#</a></h3>
<p>If we are trying to minimize a function with a single independent variable, the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize_scalar()</span></code> is likely a good choice. As a simple example, we will find the radius of minimal energy for two xenon atoms using the Lennard-Jones equation below which describes the potential energy with respect to the distance, <span class="math notranslate nohighlight">\(r\)</span>, between the two atoms. In this example, <span class="math notranslate nohighlight">\(\sigma\)</span> = 4.10 angstroms and <span class="math notranslate nohighlight">\(\epsilon\)</span> = 1.77 kJ/mol.</p>
<div class="math notranslate nohighlight">
\[ PE = 4 \epsilon \left[ \left(\frac{\sigma}{r}\right)^{12} - \left(\frac{\sigma}{r}\right)^6 \right] \]</div>
<p>Being that energy described by the Lennard-Jones energy equation is what we are trying to minimize, this is our objective function. We first need to define this equation as a Python function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">PE_LJ</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">4.10</span> <span class="c1">#kJ/mol</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="mf">1.77</span> <span class="c1">#angstroms</span>
    <span class="n">PE</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="p">(</span> <span class="p">(</span><span class="n">sigma</span><span class="o">/</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mi">12</span> <span class="o">-</span> <span class="p">(</span><span class="n">sigma</span><span class="o">/</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mi">6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">PE</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we will feed our objective function into the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize_scalar()</span></code> function along with some constraints. This is known as <em>constrained optimization</em> and is accomplished by setting the <code class="docutils literal notranslate"><span class="pre">method='bounded'</span></code> and setting the <code class="docutils literal notranslate"><span class="pre">bounds=</span></code> to the range of values the function will operate in. In this case, we are constraining the values of <span class="math notranslate nohighlight">\(r\)</span> to a specific range.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize_scalar</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="p">)</span>
</pre></div>
</div>
<p>Creating bounds is typically optional, but if you know roughly where the minimum will be or where it cannot be, this is helpful information. In this example, it is important to provide constraints on <span class="math notranslate nohighlight">\(r\)</span> to ensure the <code class="docutils literal notranslate"><span class="pre">minimize_scalar()</span></code> function does not try r = 0 and generate a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Because we imported the <code class="docutils literal notranslate"><span class="pre">optimize</span></code> module explicitley in this chapter, calling any function from inside the <code class="docutils literal notranslate"><span class="pre">scipi.optimize</span></code> module does not need to include <code class="docutils literal notranslate"><span class="pre">scipy</span></code>.</p>
</div>
</aside>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize_scalar</span><span class="p">(</span><span class="n">PE_LJ</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> 
                               <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bounded&#39;</span><span class="p">)</span>
<span class="n">opt</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> message: Solution found.
 success: True
  status: 0
     fun: -4.099999999992542
       x: 1.986757378942203
     nit: 21
    nfev: 21
</pre></div>
</div>
</div>
</div>
<p>Alternatively, we can use the <code class="docutils literal notranslate"><span class="pre">bracket=(a,</span> <span class="pre">b)</span></code> argument where <em>f(b)</em> &lt; <em>f(a)</em>. This argument is different from the <code class="docutils literal notranslate"><span class="pre">bounds=</span></code> argument in that instead of telling the function a region to search, it tells the <code class="docutils literal notranslate"><span class="pre">minimize_scalar()</span></code> function the <em>direction</em> to search for the minimum. The minimum does not need to be between <em>a</em> and <em>b</em>, but it simply tells the function that if it moves in the direction of <em>a</em> <span class="math notranslate nohighlight">\(\rightarrow\)</span> <em>b</em>, it will be moving <em>toward</em> the minimum.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">bracket=</span></code> argument can also accept three values,<code class="docutils literal notranslate"><span class="pre">bracket=(a,</span> <span class="pre">b,</span> <span class="pre">c)</span></code>, where <span class="math notranslate nohighlight">\(f\)</span>(a) &gt; <span class="math notranslate nohighlight">\(f\)</span>(b) &lt; <span class="math notranslate nohighlight">\(f\)</span>(c). This is even more helpful to the minimization function but also requires more foreknowledge from the user about the function being minimized.</p>
</div>
</aside>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize_scalar</span><span class="p">(</span><span class="n">PE_LJ</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span>
<span class="n">opt</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> message: 
          Optimization terminated successfully;
          The returned value satisfies the termination criteria
          (using xtol = 1.48e-08 )
 success: True
     fun: -4.099999999999997
       x: 1.9867578344041286
     nit: 23
    nfev: 26
</pre></div>
</div>
</div>
</div>
<p>After running our optimization function, an <code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code> object is returned. This object has a series of attributes listed above, but the two most important are <code class="docutils literal notranslate"><span class="pre">success</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>. The <code class="docutils literal notranslate"><span class="pre">success</span></code> attribute tells us if the optimization function was successful at converging on a solution while the <code class="docutils literal notranslate"><span class="pre">x</span></code> attribute is the optimized solution. We can access the solution using <code class="docutils literal notranslate"><span class="pre">opt.x</span></code> to learn that the minimized distance according to the  Lennard-Jones energy equation is 1.99 angstroms.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">opt</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>np.float64(1.9867578344041286)
</pre></div>
</div>
</div>
</div>
<p>Being that our energy function is only univariant, we can easily visualize the function and our minimized solution (orange dot) as done below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1.7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
<span class="n">PE</span> <span class="o">=</span> <span class="n">PE_LJ</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">PE</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;energy function&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">PE_LJ</span><span class="p">(</span><span class="n">opt</span><span class="o">.</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;minimum&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Distance, Angstroms&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Potential Energy, kJ/mol&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/7b90dcfcecab3595c2dab6213d0af91f7af1ce7d769859ee56e00987bab27597.svg" src="../../_images/7b90dcfcecab3595c2dab6213d0af91f7af1ce7d769859ee56e00987bab27597.svg" />
</div>
</div>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Optimization functions can use algorithms with random components, so if they are run multiple times, variations in the results may be observed. The results typically vary only slightly, but sometimes more significant variations may be observed such as if there are multiple minima or maxima in the objective function.</p>
</div>
</aside>
<div class="seealso admonition">
<p class="admonition-title">How it works…</p>
<p>The goal of optimization is to minimize the objective function which can be accomplished through a number of algorithms. Knowledge of these algorithms is not required to use optimization, but if you are curious, here is the view from 10,000 feet. Despite the wide variety of algorithms available, they generally operate by an almost trial-and-error approach. They start with initial input values for the objective function and then try slightly different input values. If the new input values decrease the objective function, they are accepted, and if they increase the objective function, they are rejected. This continues on for a number of iterations finding values that progressively decrease the objective function until the algorithm can no longer minimize the objective function any further. The final input values are then returned by the optimization function as the optimized values. Optimization algorithms can differ by, for example, how they decide which input values to try next or how different the subsequent input values to try should be. See <a class="reference internal" href="#fr14"><span class="std std-ref">Further Reading</span></a> for more information on optimization algorithms.</p>
</div>
</section>
<section id="minimization-for-maximization">
<span id="id4"></span><span id="index-3"></span><h3>14.1.2 Minimization for Maximization<a class="headerlink" href="#minimization-for-maximization" title="Link to this heading">#</a></h3>
<p>The SciPy library does not contain any maximization functions, but maximization functions are not really necessary as minimizing the negative of a function provides the maximum. For example, below we have the radial probability function for the hydrogen 3s orbital. For convenience, the SymPy library’s <code class="docutils literal notranslate"><span class="pre">sympy.physics</span></code> module is used to generate the 3s radial function (<span class="math notranslate nohighlight">\(\psi\)</span>, <code class="docutils literal notranslate"><span class="pre">psi</span></code>) as a Python function. For this maximization example, let’s find the radius of maximum probability for the electron. The normalized probability can be calculated by <span class="math notranslate nohighlight">\(\psi ^2 r^2\)</span> where <span class="math notranslate nohighlight">\(r\)</span> is the distance from the nucleus.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sympy</span>
<span class="kn">from</span> <span class="nn">sympy.physics.hydrogen</span> <span class="kn">import</span> <span class="n">R_nl</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s1">&#39;R&#39;</span><span class="p">)</span>

<span class="n">psi_expr</span> <span class="o">=</span> <span class="n">R_nl</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="c1"># generate wave function using SymPy</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">psi_expr</span><span class="p">,</span> <span class="s1">&#39;numpy&#39;</span><span class="p">)</span> <span class="c1"># convert to a Python function</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">psi</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># r is in bohrs (~0.529 anstroms)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.11</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Radius, $a_0$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability Density&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/8f2756f3817797594dc8d8d15f256aed32f5a7f31577f1313ff2c6cb9aff2021.svg" src="../../_images/8f2756f3817797594dc8d8d15f256aed32f5a7f31577f1313ff2c6cb9aff2021.svg" />
</div>
</div>
<p>There are multiple ways to make the function negative like including a negative sign in the Python function definition. Our Python function has already been created, so below we will make the radial probability density negative using a <code class="docutils literal notranslate"><span class="pre">lambda</span></code> function (see <a class="reference internal" href="../chapter_02/chap_02_notebook.html#id6"><span class="std std-ref">section 2.1.4</span></a> for review on lambda functions).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mx</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize_scalar</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mx</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> message: 
          Optimization terminated successfully;
          The returned value satisfies the termination criteria
          (using xtol = 1.48e-08 )
 success: True
     fun: -0.014833612579485785
       x: 0.7400370693225894
     nit: 13
    nfev: 16
</pre></div>
</div>
</div>
</div>
<p id="index-4">The value returned is the first local maximum but not the global maximum we are seeking. To ensure we get the global maximum, we need to add a constraint for the range of radii used by the optimization function.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mx</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize_scalar</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">psi</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                              <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bounded&#39;</span><span class="p">)</span>
<span class="n">mx</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span> message: Solution found.
 success: True
  status: 0
     fun: -0.10153431119853075
       x: 13.074031887574048
     nit: 11
    nfev: 11
</pre></div>
</div>
</div>
</div>
<p>The global maximum is plotted as an orange dot below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">psi</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;probability function&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">psi</span><span class="p">(</span><span class="n">mx</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mx</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;maximum&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">30</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.11</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Radius, $a_0$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability Density&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">margins</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/35c8ddd2800f84b7d8989a7e8f018e0739d19ca8e71ce84830a81749e16547d9.svg" src="../../_images/35c8ddd2800f84b7d8989a7e8f018e0739d19ca8e71ce84830a81749e16547d9.svg" />
</div>
</div>
</section>
<section id="multivarient-minimization">
<span id="id5"></span><span id="index-5"></span><h3>14.1.3 Multivarient Minimization<a class="headerlink" href="#multivarient-minimization" title="Link to this heading">#</a></h3>
<p>One of the key minimization functions in the <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module is the <code class="docutils literal notranslate"><span class="pre">minimize()</span></code> function which is capable of minimizing multiple variables simultaneously. This function requires at least two arguments, the objective function and initial guesses for each value as a list or tuple.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="p">(</span><span class="n">guess</span><span class="p">))</span>
</pre></div>
</div>
<p>As an example, we will calculate the equilibrium concentrations for a tandem equilibrium shown below between three different isomers assuming we place an initial 122 mmol of the isomer A into solution and allow it to equilibrate at 25 <span class="math notranslate nohighlight">\(^o\)</span>C. The two equilibrium constants for this equilibrium are <em>K</em><span class="math notranslate nohighlight">\(_1\)</span>=5.0 and <em>K</em><span class="math notranslate nohighlight">\(_2\)</span>=0.80.</p>
<div class="math notranslate nohighlight">
\[ A {\stackrel{K_1}{\rightleftharpoons}} B {\stackrel{K_2}{\rightleftharpoons}} C\]</div>
<p>To solve this problem, we need to adjust the three isomer concentrations, our variables, such that they get as close as possible to the equilibrium ratios set by the equilibrium constants.</p>
<p>The first step is to write an objective function as a Python function, <code class="docutils literal notranslate"><span class="pre">obj_func()</span></code>, that quantifies how poor the solution is. It is the value from this function that we are minimizing to generate the optimal solution to our problem. Being that our goal is to bring the isomer quantities as close to the equilibrium ratios as possible, a reasonable objective function will calculate how far our isomer ratios are from equilibrium. The quality of our solution will be calculated from the squares of the difference between a proposed solution and the target equilibrium constants so that the further the proposed solution is from the target equilibrium values, the exponentially worse the quality of the solution will be evaluated as.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">K1</span><span class="p">,</span> <span class="n">K2</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">0.80</span>

<span class="k">def</span> <span class="nf">obj_func</span><span class="p">(</span><span class="n">guess</span><span class="p">):</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">guess</span>
    
    <span class="n">Q1</span> <span class="o">=</span> <span class="n">B</span><span class="o">/</span><span class="n">A</span>  <span class="c1"># reaction quotient</span>
    <span class="n">Q2</span> <span class="o">=</span> <span class="n">C</span><span class="o">/</span><span class="n">B</span>  <span class="c1"># reaction quotient</span>
    
    <span class="n">quality</span> <span class="o">=</span> <span class="p">(</span><span class="n">Q1</span> <span class="o">-</span> <span class="n">K1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Q2</span> <span class="o">-</span> <span class="n">K2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="k">return</span> <span class="n">quality</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we provide the <code class="docutils literal notranslate"><span class="pre">minimize()</span></code> function both our objective function and an initial guess for the quantities A, B, and C. The initial guess needs to be a single collection such as a tuple, array, or list. The output of the <code class="docutils literal notranslate"><span class="pre">minimize()</span></code> function is again an <code class="docutils literal notranslate"><span class="pre">OptimizeResult</span></code> object with the <code class="docutils literal notranslate"><span class="pre">x</span></code> attribute accessing the minimized quantities for A, B, and C, respectively.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">guess</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">equ</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">obj_func</span><span class="p">,</span> <span class="n">guess</span><span class="p">)</span>
<span class="n">equ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>  message: Optimization terminated successfully.
  success: True
   status: 0
      fun: 9.425980662206073e-14
        x: [ 1.917e-01  9.583e-01  7.667e-01]
      nit: 8
      jac: [-5.538e-06  3.657e-06 -1.149e-07]
 hess_inv: [[ 3.200e-03  1.199e-02  5.102e-03]
            [ 1.199e-02  5.824e-02  2.450e-02]
            [ 5.102e-03  2.450e-02  4.582e-01]]
     nfev: 60
     njev: 15
</pre></div>
</div>
</div>
</div>
<p>To access the minimized values, use <code class="docutils literal notranslate"><span class="pre">equ.x</span></code> in this example. We can then verify the results by calculating the equilibrium values based on the calculated equilibrium quantities.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">equ</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">equ</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>np.float64(5.000000300516061)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">equ</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">equ</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>np.float64(0.7999999371517403)
</pre></div>
</div>
</div>
</div>
<p>Both values are in excellent agreement with <span class="math notranslate nohighlight">\(K_1\)</span> and <span class="math notranslate nohighlight">\(K_2\)</span> listed above. One step still remains to solve our problem. In the above problem, it is stated that we started with 122 mmol of isomer A, so if we take the sum of the quantities of A, B, and C, they need to equal 122.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">equ</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>np.float64(1.9166790953545365)
</pre></div>
</div>
</div>
</div>
<p>They do not total to 122 mmol, so we need to scale the quantities up to a total of 122 mmol. Keep in mind that scaling up our values for A, B, and C will not change the ratios.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">scale_factor</span> <span class="o">=</span> <span class="mi">122</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">equ</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
<span class="n">scale_factor</span> <span class="o">*</span> <span class="n">equ</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([12.19999972, 61.00000228, 48.79999799])
</pre></div>
</div>
</div>
</div>
<p>The final equilibrium quanties for A, B, and C are 12.2, 61.0, and 48.8 mmol, respectively.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>It is important to recognize that just because an optimization function generates an answer does not mean that it is indeed the correct answer for your problem. The generated answer is the optimization algorithm’s best effort in producing the optimal result which may be, for example, a local minimum instead of the global minimum. If there is a way to verify the answer such as is done in the equilibrium example above, this is a prudent last step before using this information.</p>
</div>
</section>
</section>
<section id="fitting-equations-to-data">
<span id="id6"></span><span id="index-7"></span><span id="index-6"></span><h2>14.2 Fitting Equations to Data<a class="headerlink" href="#fitting-equations-to-data" title="Link to this heading">#</a></h2>
<p>An common application of optimization is fitting an equation to a series of data points such as a linear regression. While linear regression also  happens to have an analytical solution demonstrated in <a class="reference internal" href="../chapter_08/chap_08_notebook.html#id15"><span class="std std-ref">section 8.3.3</span></a>, we will solve it here using optimization. In the figure below, a regression line (solid orange) runs through the data points. The <em>residuals</em> are the difference between the regression line and the data points (green vertical dotted lines). The goal of linear regression is to generate a regression line that minimizes these residuals.</p>
<div class="cell tag_remove-input docutils container">
<div class="cell_output docutils container">
<img alt="../../_images/a378df21bc8e81cd035d1e4613084abbdd94bf01ca2c2f2f405d17a4590ebaec.svg" src="../../_images/a378df21bc8e81cd035d1e4613084abbdd94bf01ca2c2f2f405d17a4590ebaec.svg" />
</div>
</div>
<p><strong>Figure 1</strong> An example of a line of best fit (solid orange) running through data points (blue) with residuals (green dashed) shown as the difference on the <span class="math notranslate nohighlight">\(y\)</span>-axis between the data point and linear regression.</p>
<p id="index-8">One of the major questions in regression is how do we measure the quality of the fit. We could in principle use the total absolute sum of the residuals, known as the <em>lease absolute deviation</em> cost or objective function, but the commonly accepted objective function for fitting equations to data is <em>mean square error (MSE)</em> function. This is the average of the square of the difference between the equation’s predictions and the actual data points, or another way of wording this is MSE is the average square residual of the fit line. The MSE equation is shown below where <span class="math notranslate nohighlight">\(f_i\)</span> is the <em>y</em>-value from the regression line, <span class="math notranslate nohighlight">\(y_i\)</span> is the data point <em>y</em>-value, and <span class="math notranslate nohighlight">\(N\)</span> is the number of data points.</p>
<div class="math notranslate nohighlight">
\[ MSE = \frac{1}{N} \sum_{i=1}^{N}{(f_i - y_i)^2} \]</div>
<p>There are two general types of regression: linear regression and nonlinear regression. The key difference is that the former fits data to a linear equation (or plane or hyperplane for higher dimensions) while the latter fits data to nonlinear equations.</p>
<section id="linear-equations">
<span id="id7"></span><span id="index-9"></span><h3>14.2.1 Linear Equations<a class="headerlink" href="#linear-equations" title="Link to this heading">#</a></h3>
<p>There are numerous examples of linear equations in chemistry, and often when equations are nonlinear, they can be rearranged into a linear form. One classic example of a linear trend is the absorption of light being passed through a solution of colored analyte (i.e., material being quantified) with respect to the concentration of the analyte. This is related by Beer’s law shown below where <span class="math notranslate nohighlight">\(A\)</span> is absorption, <span class="math notranslate nohighlight">\(\epsilon\)</span> is the molar absorptivity constant for a particular analyte, <span class="math notranslate nohighlight">\(b\)</span> is path length of the sample, and <span class="math notranslate nohighlight">\(C\)</span> is the concentration of analyte.</p>
<div class="math notranslate nohighlight">
\[ A = \epsilon bC \]</div>
<p>Being that the path length for our instrument is 1 cm, which is quite common, this equation simplifies to the following.</p>
<div class="math notranslate nohighlight">
\[ A = \epsilon C \]</div>
<p>By measuring the absorbance of multiple samples of analyte at known concentrations, the absorbance can be plotted with respect to concentration, and the slope of the linear trend is the molar absorptivity, <span class="math notranslate nohighlight">\(\epsilon\)</span>.</p>
<p>As our sample data, let’s again use the copper cuprizone data we saw in chapter 8.</p>
<p><strong>Table 1</strong> Beer-Lambert Law Data for Copper Cuprizone</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Concentration (10<span class="math notranslate nohighlight">\(^{-6}\)</span> M)</p></th>
<th class="head text-center"><p>Absorbance</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1.0</p></td>
<td class="text-center"><p>0.0154</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>3.0</p></td>
<td class="text-center"><p>0.0467</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>6.0</p></td>
<td class="text-center"><p>0.0930</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>15</p></td>
<td class="text-center"><p>0.2311</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>25</p></td>
<td class="text-center"><p>0.3925</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>35</p></td>
<td class="text-center"><p>0.5413</p></td>
</tr>
</tbody>
</table>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0e-06</span><span class="p">,</span> <span class="mf">3.0e-06</span><span class="p">,</span> <span class="mf">6.0e-06</span><span class="p">,</span> <span class="mf">1.5e-05</span><span class="p">,</span> <span class="mf">2.5e-05</span><span class="p">,</span> <span class="mf">3.5e-05</span><span class="p">])</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0154</span><span class="p">,</span> <span class="mf">0.0467</span><span class="p">,</span> <span class="mf">0.0930</span> <span class="p">,</span> <span class="mf">0.2311</span><span class="p">,</span> <span class="mf">0.3975</span><span class="p">,</span> <span class="mf">0.5413</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>The function we will use to fit this data is the <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> function which performs a least-square minimization that fits an equation to the data provided. Despite this function being often described for fitting an equation to nonlinear data, this function is highly versatile and can fit both linear and nonlinear data. This function requires the theoretical equation, <code class="docutils literal notranslate"><span class="pre">func</span></code>, in the form of a Python function, the independent variable, <code class="docutils literal notranslate"><span class="pre">xdata</span></code>, and the dependent variable, <code class="docutils literal notranslate"><span class="pre">ydata</span></code>. The <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function also allows the user to optionally provide an initial guess for the equation variables/constants, <code class="docutils literal notranslate"><span class="pre">p0</span></code>. This can help speed up the process for more challenging problems and helps ensure the algorithm converges on a reasonable solution.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="p">())</span>
</pre></div>
</div>
<p>Below we have defined a Python function describing our equation that will be used to fit the data. The Python function used with <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> requires that the first argument of the Python function must be the independent variable(s), and all the rest of the arguments are the parameters used to fit the equation to the data. In this case, these are the slope, <span class="math notranslate nohighlight">\(m\)</span>, and the <em>y</em>-intercept, <span class="math notranslate nohighlight">\(b\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">lin_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
</div>
</div>
<p>The objective function is then provided to the <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> function along with the data to fit. The <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function returns two arrays: the optimized parameters and the estimated covariance of the optimized parameters. We are only concerned with the optimized parameters right now, so we use the <code class="docutils literal notranslate"><span class="pre">__</span></code> junk variable to hold the covariance array.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">const</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">lin_func</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
<span class="n">const</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 1.55886228e+04, -5.51832054e-06])
</pre></div>
</div>
</div>
</div>
<p>According to the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function, the slope is 1.55 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^4\)</span> cm<span class="math notranslate nohighlight">\(^{-1}\)</span>M<span class="math notranslate nohighlight">\(^{-1}\)</span> while the <em>y</em>-intercept is -5.45 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-6}\)</span>.</p>
</section>
<section id="nonlinear-regression">
<span id="id8"></span><span id="index-12"></span><span id="index-11"></span><span id="index-10"></span><h3>14.2.2 Nonlinear Regression<a class="headerlink" href="#nonlinear-regression" title="Link to this heading">#</a></h3>
<p>Optimization can also be used to find the best fit for nonlinear data based off of a theoretical equation. One application of nonlinear fitting is to fit data to a theoretical rate law as a means of determining one or more rate constants in the equation. For this, we will again use the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function from the <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module.</p>
<p>To demonstrate this process, let’s consider the two-step reaction of A + B <span class="math notranslate nohighlight">\(\rightarrow\)</span> P catalyzed by a metal catalyst M.</p>
<div class="math notranslate nohighlight">
\[ M + A \underset{k_{r1}}{\stackrel{k_1}{\rightleftharpoons}} MA \]</div>
<div class="math notranslate nohighlight">
\[ MA + B \stackrel{k_2}\rightarrow P + M\]</div>
<p>The theoretical rate law for this two-step reaction is shown below.</p>
<div class="math notranslate nohighlight">
\[ Rate = \frac{k_2k_1[M][A][B]}{k_{r1} + k_2[B]} \]</div>
<p>We need to again define the theoretical equation in the form of a Python function. Our function calculates the rate of the chemical reaction versus the concentration of B, but it would also work using data for rate versus the concentration of A depending upon what data you happen to have.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">frate</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">k2</span><span class="p">):</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">k2</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">M</span> <span class="o">*</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">kr1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rate</span>
</pre></div>
</div>
</div>
</div>
<p>For our example, we will generate some simulated data with random noise mixed in it. The values of our rate constants will be k<span class="math notranslate nohighlight">\(_1\)</span>=1.2, k<span class="math notranslate nohighlight">\(_{r2}\)</span>=0.48, k<span class="math notranslate nohighlight">\(_2\)</span>=4.29, and we will set [A] = 0.50 M and [M] = 1.2 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-3}\)</span> M. The concentrations of [A] and [M] are unchanged during the course of the rate measurement (e.g., using the method of initial rates).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">M</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="mf">1.2e-3</span><span class="p">,</span> <span class="mf">0.50</span>

<span class="n">k1</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.48</span><span class="p">,</span> <span class="mf">4.29</span>

<span class="n">points</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="n">points</span><span class="p">)</span>
<span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
<span class="n">rate</span> <span class="o">=</span> <span class="n">frate</span><span class="p">(</span><span class="n">conc</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span> <span class="o">+</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">/</span><span class="mi">40000</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">conc</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;[B], M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Rate, M/s&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/1254ed5217dd52836856ba4f4126ea3edb83a8b31e5a36a34bb16da3f1a99c9e.svg" src="../../_images/1254ed5217dd52836856ba4f4126ea3edb83a8b31e5a36a34bb16da3f1a99c9e.svg" />
</div>
</div>
<p>Now that we have our data, we can fit it to the theoretical equation to extract the rate constants.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">const</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">frate</span><span class="p">,</span> <span class="n">conc</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">const</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1.22558323, 0.50705095, 4.49294906])
</pre></div>
</div>
</div>
</div>
<p>These rate constants are in good agreement with those used to generate the data. We can also plot the simulated data versus the rate equation generated by our curve fitting below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">conc</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">frate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">const</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">const</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">const</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> 
         <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Calculated Regression&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;[B], M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Rate, M/s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">7</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/6670b5e9b24904dca3eb7f44d55691054fccf72d99fc1ae57758200871d4163d.svg" src="../../_images/6670b5e9b24904dca3eb7f44d55691054fccf72d99fc1ae57758200871d4163d.svg" />
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you are optimizing a function with multiple parameters, bounds are formatted with two lists or tuples. The first contains the lower bounds while the second contains the upper bounds as demonstrated below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bounds</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_low</span><span class="p">,</span> <span class="n">b_low</span><span class="p">,</span> <span class="n">c_low</span><span class="p">),</span> <span class="p">(</span><span class="n">a_high</span><span class="p">,</span> <span class="n">b_high</span><span class="p">,</span> <span class="n">c_high</span><span class="p">))</span>
<span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Another feature of the <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> function is that it also accepts the uncertainty or errors in each data point. All regression examples seen so far in this book assume that each data point has the same level of uncertainty, but it is not uncommon for data to have different uncertainties. If your uncertainty varies, you can provide the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function with the uncertainties as standard deviations to the <code class="docutils literal notranslate"><span class="pre">sigma=</span></code> argument as an array-like object (e.g., list, set, or NumPy array). When uncertainties are provided, data points with more uncertainty have less influence on the resulting regression than data points with less uncertainty. See the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit"><code class="docutils literal notranslate"><span class="pre">scipy.optimize.curve_fit()</span></code></a> documentation for more information and options.</p>
<p>In the example below, we will again fit concentration versus kinetic rate data from the above two-step chemical reaction. This time, we also have an array, <code class="docutils literal notranslate"><span class="pre">uncertainty</span></code>, that provides degrees of uncertainty for the rates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">uncertainty</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.10e-6</span><span class="p">,</span> <span class="mf">0.12e-6</span><span class="p">,</span> <span class="mf">0.15e-6</span><span class="p">,</span> <span class="mf">0.18e-6</span><span class="p">,</span> <span class="mf">2.0e-6</span><span class="p">,</span> 
               <span class="mf">2.1e-6</span><span class="p">,</span> <span class="mf">2.3e-6</span><span class="p">,</span> <span class="mf">2.6e-6</span><span class="p">,</span> <span class="mf">2.9e-6</span><span class="p">,</span> <span class="mf">3.0e-6</span><span class="p">,</span>
               <span class="mf">3.0e-6</span><span class="p">,</span> <span class="mf">3.1e-6</span><span class="p">,</span> <span class="mf">2.9e-6</span><span class="p">,</span> <span class="mf">3.5e-6</span><span class="p">,</span> <span class="mf">3.9e-6</span><span class="p">,</span>
               <span class="mf">4.0e-6</span><span class="p">,</span> <span class="mf">4.1e-6</span><span class="p">,</span> <span class="mf">4.4e-6</span><span class="p">,</span> <span class="mf">5.7e-6</span><span class="p">,</span> <span class="mf">5.3e-6</span><span class="p">]</span> <span class="c1"># M/s</span>

<span class="n">const</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">frate</span><span class="p">,</span> <span class="n">conc</span><span class="p">,</span> <span class="n">rate</span><span class="p">,</span> 
                               <span class="n">sigma</span> <span class="o">=</span> <span class="n">uncertainty</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">const</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1.21309944, 0.48076176, 4.48808724])
</pre></div>
</div>
</div>
</div>
<p>Comparing these constants to those calculated with the assumption of constant uncertainty, the values are similar but have a noticeable difference. The general rule is that the greater the <em>variation</em> in the uncertainties, the more the constants will differ from those derived with the assumption of constant uncertainty.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fitting data to a mathematical function can also be accomplished using the <code class="docutils literal notranslate"><span class="pre">optimize.least_squares()</span></code> function. The key difference between using <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> and <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code> is that the former accepts the theoretical equation and data directly while the latter requires a Python function that calculates the <a class="reference internal" href="#id6"><span class="std std-ref">residuals</span></a>. Interestingly, the source code for the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function calls the <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code> function. We use the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function here as it is more intuitive and convenient.</p>
<p>There is another related function, <code class="docutils literal notranslate"><span class="pre">optimize.leastsq()</span></code>, that performs a similar operation but only uses the Levenberg-Marquardt algorithm and is described as legacy on the <a class="reference external" href="http://scipy.org">scipy.org</a> website. The <code class="docutils literal notranslate"><span class="pre">optimize.least_squares()</span></code> function is more versatile and is likely the better choice of the two.</p>
</div>
</section>
<section id="mixed-analyte-example">
<span id="id9"></span><span id="index-13"></span><h3>14.2.3 Mixed Analyte Example<a class="headerlink" href="#mixed-analyte-example" title="Link to this heading">#</a></h3>
<p>Below is an additional example where we use optimization to determine the concentrations of three different dyes mixed together and analyzed by UV-Vis spectroscopy. This example was inspired by a <em>Journal of Chemical Education</em> article by <a class="reference external" href="https://doi.org/10.1021/acs.jchemed.9b00421">Jesse Maccione, Joseph Welch, and Emily C. Heider</a>. By Beer’s law, the absorbance (A) of an analyte is the product of the molar absoptivity constant (<span class="math notranslate nohighlight">\(\epsilon\)</span>) for that analyte, the path length in cm (<span class="math notranslate nohighlight">\(b\)</span>), and concentration (<span class="math notranslate nohighlight">\(C\)</span>).</p>
<div class="math notranslate nohighlight">
\[ A = \epsilon bC \]</div>
<p>If there are multiple analytes in solution, the total absorbance (A<span class="math notranslate nohighlight">\(_{tot}\)</span>) is equal to the sum of the absorbances for the individual analytes. In our example, we will be dealing with a mixture of red, blue, and yellow dyes.</p>
<div class="math notranslate nohighlight">
\[ A_{tot} = A_{red} + A_{blue} + A_{yellow} \]</div>
<p>We ultimately want concentrations of the dyes, so we can substitute in Beer’s law for the three dye absorbances.</p>
<div class="math notranslate nohighlight">
\[  A_{tot} = \epsilon_{red} bC_{red} + \epsilon_{blue} bC_{blue} + \epsilon_{yellow} bC_{yellow} \]</div>
<p>The path length is a constant that depends upon the instrument, and the molar absorptivity constants (<span class="math notranslate nohighlight">\(\epsilon\)</span>) are constants that depend upon the analytes and the wavelength we are measuring absorbances at. This means that for a particular set of dyes and instrument, the total absorbance (<span class="math notranslate nohighlight">\(A_{tot}\)</span>) depends upon the unknown concentrations of individual dyes. Because we have three unknowns, we need three equations to solve for the unknowns. This can be accomplished by measuring the absorbance and molar absorptivity at a minimum of three different wavelengths as demonstrated in <a class="reference internal" href="../chapter_08/chap_08_notebook.html#id14"><span class="std std-ref">section 8.3.2</span></a>. In this chapter, we will instead measure absorbances at <em>every</em> nanometer from 400 nm to 850 nm and allow the optimization function to fit the total absorbances by adjusting the individual dye concentrations.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>While including more data points from the spectra can often lead to better results, using too many points can sometimes have the opposite effect due to overfitting noise. It is often best to select regions where there is the largest signal-to-noise ratio to avoid fitting too much noise.</p>
</div>
</aside>
<p>First, we will import the absorbance data from the <code class="docutils literal notranslate"><span class="pre">food_coloring.csv</span></code> file using pandas and plot it to see what the data look like. In the CSV file, there are UV-Vis spectra for pure red, pure blue, pure yellow, and a mixture of the three.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;data/food_coloring.csv&#39;</span><span class="p">)</span>
<span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;nm&#39;</span><span class="p">]</span>
<span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;nm&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">A_red</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;red_40&#39;</span><span class="p">]</span>
<span class="n">A_yellow</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;yellow_6&#39;</span><span class="p">]</span>
<span class="n">A_blue</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;blue_1&#39;</span><span class="p">]</span>
<span class="n">A_mix</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mix_1&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">A_blue</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;C0&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">A_yellow</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;C8&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">A_red</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;C3&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">A_mix</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;C7&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelength, nm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Absorbance&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;blue 1&#39;</span><span class="p">,</span> <span class="s1">&#39;yellow 6&#39;</span><span class="p">,</span> <span class="s1">&#39;red 40&#39;</span><span class="p">,</span> <span class="s1">&#39;mixture&#39;</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/17b0f216da73c52538c79b4ecdac207bcfe030cb9b49bd27d78e51a353597463.svg" src="../../_images/17b0f216da73c52538c79b4ecdac207bcfe030cb9b49bd27d78e51a353597463.svg" />
</div>
</div>
<p>Next, we will use the absorbances for each pure dye sample to find the molar absorptivities using Beer’s law. The path length, <span class="math notranslate nohighlight">\(b\)</span>, in this instrument is 1 cm, and the molarities are known from the experimental setup. That is, below  we are solving for molar absorptivity (<span class="math notranslate nohighlight">\(\epsilon\)</span>) by the following.</p>
<div class="math notranslate nohighlight">
\[ \epsilon = \frac{A}{C} \]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eps_red</span> <span class="o">=</span> <span class="n">A_red</span> <span class="o">/</span> <span class="mf">4.09e-5</span>
<span class="n">eps_blue</span> <span class="o">=</span> <span class="n">A_blue</span> <span class="o">/</span> <span class="mf">5.00e-6</span>
<span class="n">eps_yellow</span> <span class="o">=</span> <span class="n">A_yellow</span> <span class="o">/</span> <span class="mf">2.92e-5</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we will write a Python function that calculates the total absorbance from the individual concentrations and molar absorptivities, and we will provide this function to the <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> function. The fitting parameters are the calculated concentrations of the individual dyes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">absorb</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">C_red</span><span class="p">,</span> <span class="n">C_blue</span><span class="p">,</span> <span class="n">C_yellow</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">eps_red</span> <span class="o">*</span> <span class="n">C_red</span> <span class="o">+</span> <span class="n">eps_blue</span> <span class="o">*</span> <span class="n">C_blue</span> <span class="o">+</span> <span class="n">eps_yellow</span> <span class="o">*</span> <span class="n">C_yellow</span>

<span class="n">fit</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="n">absorb</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">A_mix</span><span class="p">)</span>
<span class="n">fit</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1.44922873e-05, 2.84592011e-06, 1.26645031e-05])
</pre></div>
</div>
</div>
</div>
<p>The end result is that the red, blue, and yellow dyes have concentrations of 1.45 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-5}\)</span> M, 2.85 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-6}\)</span> M, and 1.27 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-5}\)</span> M.</p>
<p>Below is a quick demonstration on how to also solve this problem using the <code class="docutils literal notranslate"><span class="pre">optimize.lease_squares()</span></code> function. As mentioned earlier, both the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> and <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code> functions can be used to solve the same problems. The <code class="docutils literal notranslate"><span class="pre">least_squares()</span></code> function requires a Python function that calculates the residuals (i.e., the difference between the calculated and measured absorbances) instead of the theoretical equation. This function also requires an initial guess for the fit parameters. Even if you don’t know the concentrations, just give some reasonable value. In this case, we guessed 1 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-3}\)</span> M for each dye.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">residuals</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="n">C_red</span><span class="p">,</span> <span class="n">C_blue</span><span class="p">,</span> <span class="n">C_yellow</span> <span class="o">=</span> <span class="n">X</span>
    <span class="n">A_calc</span> <span class="o">=</span> <span class="n">C_red</span> <span class="o">*</span> <span class="n">eps_red</span> <span class="o">+</span> <span class="n">C_blue</span> <span class="o">*</span> <span class="n">eps_blue</span> <span class="o">+</span> <span class="n">C_yellow</span> <span class="o">*</span> <span class="n">eps_yellow</span>
    <span class="k">return</span> <span class="n">A_mix</span> <span class="o">-</span> <span class="n">A_calc</span>

<span class="n">lstsq</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">least_squares</span><span class="p">(</span><span class="n">residuals</span><span class="p">,</span> <span class="p">(</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">))</span>
<span class="n">lstsq</span><span class="o">.</span><span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([1.44922873e-05, 2.84592011e-06, 1.26645031e-05])
</pre></div>
</div>
</div>
</div>
<p>The resulting concentrations for the three dyes appears identical (or nearly so) to those calculated by the <code class="docutils literal notranslate"><span class="pre">curve_fit()</span></code> function.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The above approach assumes that the contribution of each dye is purely additive, so the contribution of each dye to the total absorbance is only a function of its own concentration. This means, for example, that the interaction of different dyes with each other in solution is assumed to be negligible.</p>
</div>
</aside>
</section>
</section>
<section id="root-finding">
<span id="id10"></span><span id="index-14"></span><h2>14.3 Root Finding<a class="headerlink" href="#root-finding" title="Link to this heading">#</a></h2>
<p>Root finding is the process of determining where a function equals zero, <span class="math notranslate nohighlight">\(f(a,b,...) = 0\)</span>. Being that any equation can be rearranged to equal zero, this is a versatile way of solving an equation. If the function is univariant, <span class="math notranslate nohighlight">\(f(a)=0\)</span>, this task may sometimes seem trivial even without optimization algorithms, but as the complexity of the equation or number of variables increases, using optimization algorithms can be beneficial.</p>
<p>Like the minimization functions above, there are two related versions of the root finding functions: <code class="docutils literal notranslate"><span class="pre">scipy.optimize.root()</span></code> and <code class="docutils literal notranslate"><span class="pre">scipy.optimize.root_scalar()</span></code>. The key difference is that the <code class="docutils literal notranslate"><span class="pre">root()</span></code> function can solve for both univariant and multivariant functions while <code class="docutils literal notranslate"><span class="pre">root_scalar()</span></code> can only solve for univariant functions. Both functions require a function, <code class="docutils literal notranslate"><span class="pre">func</span></code>, to find the root of, and <code class="docutils literal notranslate"><span class="pre">root()</span></code> function also requires an initial guess, <code class="docutils literal notranslate"><span class="pre">x0</span></code>. The <code class="docutils literal notranslate"><span class="pre">root_scalar()</span></code> function also allows for an optional range of values that bracket the root, <code class="docutils literal notranslate"><span class="pre">bracket=</span></code> to be provides by the user.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">root</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
<span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">root_scalar</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
</pre></div>
</div>
<p>As a root finding example, we can locate the nodes in a radial wave function for the hydrogen 3s orbital. Because there is only one variable, <span class="math notranslate nohighlight">\(r\)</span>, we can use the <code class="docutils literal notranslate"><span class="pre">scipy.optimize.root_scalar()</span></code> function. Below, we first define our radial wave function as a Python function, <code class="docutils literal notranslate"><span class="pre">orbital_3s</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">orbital_3s</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="n">wf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">27</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">9</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wf</span>
</pre></div>
</div>
</div>
</div>
<p>Before we find the roots, let’s visualize the function to see what we are dealing with. The horizontal dotted line at <em>y</em> = 0 is provided as a visual guide. The roots are located where the solid line of the wave function intersects with the dotted line.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">psi_3s</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbital_3s</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Zero line&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">psi_3s</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3s radial wave function&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Radius, $a_0$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">psi$&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/99128483cfe0b26f7a967aa8b0d0cff02be1faf7d29d85ff5a0a0425f1406b28.svg" src="../../_images/99128483cfe0b26f7a967aa8b0d0cff02be1faf7d29d85ff5a0a0425f1406b28.svg" />
</div>
</div>
<p>The function has two nodes, so our <code class="docutils literal notranslate"><span class="pre">bracket=</span></code> values will determine which we will end up
solving for.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">node1</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root_scalar</span><span class="p">(</span><span class="n">orbital_3s</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">node1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      converged: True
           flag: converged
 function_calls: 11
     iterations: 10
           root: 1.901923788646684
         method: brentq
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">node2</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root_scalar</span><span class="p">(</span><span class="n">orbital_3s</span><span class="p">,</span> <span class="n">bracket</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="n">node2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>      converged: True
           flag: converged
 function_calls: 9
     iterations: 8
           root: 7.098076211353316
         method: brentq
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">psi_3s</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbital_3s</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Zero line&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">psi_3s</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;3s radial wave function&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">orbital_3s</span><span class="p">(</span><span class="n">node1</span><span class="o">.</span><span class="n">root</span><span class="p">),</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Node 1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">orbital_3s</span><span class="p">(</span><span class="n">node2</span><span class="o">.</span><span class="n">root</span><span class="p">),</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Node 2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Radius, $a_0$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">psi$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/3804c5458cf5914668506959497740a36c71ac99e8f950f845d9961fa9ce902f.svg" src="../../_images/3804c5458cf5914668506959497740a36c71ac99e8f950f845d9961fa9ce902f.svg" />
</div>
</div>
<p>The two dots above show the location of the two roots for this function which clearly are located on the nodes of the wave function.</p>
</section>
<section id="further-reading">
<span id="fr14"></span><h2>Further Reading<a class="headerlink" href="#further-reading" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module user guide. <a class="reference external" href="https://docs.scipy.org/doc/scipy/tutorial/optimize.html">https://docs.scipy.org/doc/scipy/tutorial/optimize.html</a> (free resource)</p></li>
<li><p>Watt, J.; Borhani, R.; Katsaggelos, A. K. Machine Learning Refined: Foundations, Algorithms, and Applications; 2nd ed.; Cambridge University Press, 2020, pp 21-124. These chapters are a good introduction to optimization algorithms.</p></li>
</ol>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Link to this heading">#</a></h2>
<p>Solve the following problems using Python in a Jupyter notebook and functions from the <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module. Any data file(s) refered to in the problems can be found in the <a class="reference external" href="https://github.com/weisscharlesj/SciCompforChemists/tree/master/notebooks">data</a> folder in the same directory as this chapter’s Jupyter notebook. Alternatively, you can download a zip file of the data for this chapter from <a class="reference external" href="https://github.com/weisscharlesj/data_SciCompforChem">here</a> by selecting the appropriate chapter file and then clicking the <strong>Download</strong> button.</p>
<span id="index-15"></span><ol class="arabic" id="index-16">
<li><p>A warm or hot object emits radiation in a range of wavelengths described by Plank’s law shown below where B is radiance, <span class="math notranslate nohighlight">\(\lambda\)</span> is frequency of radiation, <span class="math notranslate nohighlight">\(c\)</span> is the speed of light, <span class="math notranslate nohighlight">\(h\)</span> is Plank’s constant, <span class="math notranslate nohighlight">\(k\)</span> is Boltzmann’s constant, and <span class="math notranslate nohighlight">\(T\)</span> is temperature of the object in K.</p>
<div class="math notranslate nohighlight">
\[ B(\lambda) = \frac{2hc^2}{\lambda^5} \frac{1}{e^{\frac{hc}{\lambda kT}}-1} \]</div>
<p>Determine the wavelength of greatest radiance for an object at 5000 K using a minimization function. Hint: be sure to include an extra negative sign in the Python function that you define, and you will want to use either bounds or brackets to prevent the minimization function from trying zero and generating a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>.</p>
</li>
<li><p>The three isomers of ethyltoluene (i.e., <em>ortho</em>-, <em>meta</em>-, and <em>para</em>-) interchange under Friedel-Crafts conditions facilitated by aluminum chloride. An investigation into this isomer equilibrium by <a class="reference external" href="https://doi.org/10.1021/ja01503a026">Allen, R. H. et al.</a> experimentally determined the rate constants for the interconversion of these isomers. Using the rate constant data, the following equilibrium constants were calculated: <em>K</em><span class="math notranslate nohighlight">\(_{om}\)</span>=7.2, <em>K</em><span class="math notranslate nohighlight">\(_{pm}\)</span>=2.47, and <em>K</em><span class="math notranslate nohighlight">\(_{op}\)</span>=2.9 where each equilibrium constant is defined below.</p>
<div class="math notranslate nohighlight">
\[ K_{om}=\frac{[meta]}{[ortho]}, \quad K_{pm}=\frac{[meta]}{[para]}, \quad K_{op}={\frac{[para]}{[ortho]}}  \]</div>
<p>Using this information, calculate the percentages of each isomer at equilibrium. Compare your percentage to those provided in the above paper (in the abstract).</p>
</li>
<li><p>A sealed piston contains 0.32 moles of helium gas at 298 K. Determine the value of <span class="math notranslate nohighlight">\(R\)</span> by performing a nonlinear fit on the data below with the <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> function and the ideal gas law.</p>
<div class="math notranslate nohighlight" id="index-17">
\[ P = \frac{nRT}{V} \]</div>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Volume (L)</p></th>
<th class="head text-center"><p>Pressure (atm)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>0.401</p></td>
<td class="text-center"><p>21.8</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>0.701</p></td>
<td class="text-center"><p>11.3</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>1.22</p></td>
<td class="text-center"><p>5.17</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>1.80</p></td>
<td class="text-center"><p>5.49</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>2.39</p></td>
<td class="text-center"><p>3.86</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2.83</p></td>
<td class="text-center"><p>4.34</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3.09</p></td>
<td class="text-center"><p>2.72</p></td>
</tr>
</tbody>
</table>
</div>
</li>
<li><p>Below is the theoretical kinetic rate law for a chemical reaction of A <span class="math notranslate nohighlight">\(\rightarrow\)</span> P catalyzed by 0.001 M of a metal catalyst C. The table includes kinetic data for the rate, concentration of A, and the uncertainty in rate. Use the <code class="docutils literal notranslate"><span class="pre">optimize.curve_fit()</span></code> function to determine values for <span class="math notranslate nohighlight">\(k_1\)</span> and <span class="math notranslate nohighlight">\(K_{eq}\)</span>. Plot the data below with an overlay of calculated values using the constants that you determined to show that they are reasonable values.</p>
<div class="math notranslate nohighlight">
\[ Rate = \frac{k_1K_{eq}[A][C]}{1 + K_{eq}[A]} \]</div>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Rate, M/s</p></th>
<th class="head text-center"><p>[A], M</p></th>
<th class="head text-center"><p>Rate Uncertainty, M/s</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>2.18e-06</p></td>
<td class="text-center"><p>0.01</p></td>
<td class="text-center"><p>0.11e-6</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>1.72e-05</p></td>
<td class="text-center"><p>0.71</p></td>
<td class="text-center"><p>0.12e-6</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>2.75e-05</p></td>
<td class="text-center"><p>1.43</p></td>
<td class="text-center"><p>0.25e-6</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>4.36e-05</p></td>
<td class="text-center"><p>2.14</p></td>
<td class="text-center"><p>0.40e-6</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>5.23e-05</p></td>
<td class="text-center"><p>2.86</p></td>
<td class="text-center"><p>0.50e-6</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>5.23e-05</p></td>
<td class="text-center"><p>3.57</p></td>
<td class="text-center"><p>1.0e-6</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>6.71e-05</p></td>
<td class="text-center"><p>4.29</p></td>
<td class="text-center"><p>1.5e-6</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>6.26e-05</p></td>
<td class="text-center"><p>5.00</p></td>
<td class="text-center"><p>1.8e-6</p></td>
</tr>
</tbody>
</table>
</div>
</li>
<li id="index-18"><p>One method of solving acid-base equilibrium concentrations is through polynomials as demonstrated by <a class="reference external" href="https://doi.org/10.1021/ed081p758">F. Bamdad</a>. Below is a third-degree polynomial from the equilibria resulting from placing hydrocyanic acid (HCN) in water where <span class="math notranslate nohighlight">\(x\)</span> is the concentration of hydronium, <em>K</em><span class="math notranslate nohighlight">\(_a\)</span> is the acid equilibrium constant, <em>K</em><span class="math notranslate nohighlight">\(_w\)</span> is equilibrium constant for the autoionization of water, and [HCN]<span class="math notranslate nohighlight">\(_0\)</span> is the initial concentration of hydrocyanic acid. Solve for the concentration of hydronium using a root finding algorithm in the <code class="docutils literal notranslate"><span class="pre">scipy.optimize</span></code> module assuming [HCN]<span class="math notranslate nohighlight">\(_0\)</span> = 6.8 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-6}\)</span> M and K<span class="math notranslate nohighlight">\(_a\)</span> = 6.2 <span class="math notranslate nohighlight">\(\times\)</span> 10<span class="math notranslate nohighlight">\(^{-10}\)</span>.</p>
<div class="math notranslate nohighlight">
\[ x^3 + K_a x^2 + (K_w + [HCN]_0K_a)x - K_wK_a = 0 \]</div>
</li>
<li id="index-19"><p>The van der Waals equation is a modified form of the ideal gas law but includes two correction factors that account for intermolecular forces and the volume of gas molecules. These correction factors include constants <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> which are gas-dependent, and the values of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> can be calculated by fitting the van der Waals equation to pressure versus volume data.</p>
<div class="math notranslate nohighlight">
\[ \left(P + a\frac{n^2}{V^2} \right) (V - nb) = nRT \]</div>
<p>Load the file <code class="docutils literal notranslate"><span class="pre">PV_CO.csv</span></code> containing pressure and volume data for one mole of carbon monixide at 298 K acquired from the <a class="reference external" href="https://webbook.nist.gov/chemistry/">NIST Chemistry WebBook</a>. Fit the van der Waals equation to this dataset to determine <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> values for carbon monoxide.</p>
</li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "scicompchem-env"
        },
        kernelOptions: {
            name: "scicompchem-env",
            path: "./notebooks/chapter_14"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'scicompchem-env'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="../chapter_13/chap_13_notebook.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 13: Machine Learning using Scikit-Learn</p>
      </div>
    </a>
    <a class="right-next"
       href="../chapter_15/chap_15_notebook.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 15: Cheminformatics with RDKit</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimization">14.1 Minimization</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#univariant-minimization">14.1.1 Univariant Minimization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimization-for-maximization">14.1.2 Minimization for Maximization</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multivarient-minimization">14.1.3 Multivarient Minimization</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#fitting-equations-to-data">14.2 Fitting Equations to Data</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linear-equations">14.2.1 Linear Equations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nonlinear-regression">14.2.2 Nonlinear Regression</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#mixed-analyte-example">14.2.3 Mixed Analyte Example</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#root-finding">14.3 Root Finding</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further Reading</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Charles J. Weiss
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2017-2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  Scientific Computing for Chemists with Python is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>