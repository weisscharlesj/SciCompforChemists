

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Chapter 9: Simulations &#8212; Scientific Computing for Chemists with Python</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/chapter_09/chap_09_notebook';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Chapter 10: Plotting with Seaborn" href="../chapter_10/chap_10_notebook.html" />
    <link rel="prev" title="Chapter 8: Mathematics" href="../chapter_08/chap_08_notebook.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../introduction/intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../introduction/intro.html">
                    Scientific Computing for Chemists with Python
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../chapter_00/chap_00_notebook.html">Chapter 0: Python &amp; Jupyter Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_01/chap_01_notebook.html">Chapter 1: Basic Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_02/chap_02_notebook.html">Chapter 2: Intermediate Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_03/chap_03_notebook.html">Chapter 3: Plotting with Matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_04/chap_04_notebook.html">Chapter 4: NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_05/chap_05_notebook.html">Chapter 5: Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_06/chap_06_notebook.html">Chapter 6: Signal &amp; Noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_07/chap_07_notebook.html">Chapter 7: Image Processing &amp; Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_08/chap_08_notebook.html">Chapter 8: Mathematics</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Chapter 9: Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_10/chap_10_notebook.html">Chapter 10: Plotting with Seaborn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_11/chap_11_notebook.html">Chapter 11: Nuclear Magnetic Resonance with NMRglue</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_12/chap_12_notebook.html">Chapter 12: Machine Learning using Scikit-Learn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_13/chap_13_notebook.html">Chapter 13: Command Line &amp; Spyder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapter_14/chap_14_notebook.html">Chapter 14: Optimization and Root Finding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../genindex.html">Index</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/weisscharlesj/SciCompforChemists" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/weisscharlesj/SciCompforChemists/issues/new?title=Issue%20on%20page%20%2Fnotebooks/chapter_09/chap_09_notebook.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/chapter_09/chap_09_notebook.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Chapter 9: Simulations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deterministic-simulations">9.1 Deterministic Simulations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nuclear-magnetic-resonance-splitting">9.1.1 Nuclear Magnetic Resonance Splitting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#single-step-stepwise-chemical-kinetics">9.1.2 Single-Step Stepwise Chemical Kinetics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multistep-stepwise-chemical-kinetics">9.1.3 Multistep Stepwise Chemical Kinetics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chemical-kinetics-and-odeint">9.1.4 Chemical Kinetics and ODEINT</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#stochastic-simulations">9.2 Stochastic Simulations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radioactive-decay">9.2.1 Radioactive Decay</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#confidence-intervals">9.2.2 Confidence Intervals</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#random-flight-polymer">9.2.3 Random Flight Polymer</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further Reading</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="chapter-9-simulations">
<span id="id1"></span><h1>Chapter 9: Simulations<a class="headerlink" href="#chapter-9-simulations" title="Permalink to this heading">#</a></h1>
<div class="cell tag_remove-input docutils container">
</div>
<p>Simulations are a major component of modern chemical research either in conjunction with experimental work or by itself. A <em>digital chemical simulation</em> is a representation or mimic of a physical or chemical process using a computer with enough detail that the results provide meaningful and useful insights into the real process. Simulations do not need to represent every aspect of the real world as long as the omitted details do not reduce the accuracy or precision to a level that the simulation is no longer useful.</p>
<p>Modern chemical simulations are often quite complex and are performed with a range of free or commercial software that regrettably can obfuscate the underlying methods. This chapter aims to introduce simulations with simple methodologies that can be easily coded in Python, NumPy, and SciPy. These simulations are not designed for use in a research setting due to the low level of sophistication and do not represent the current state-of-art in the field of chemical simulations. Some of these simulations are also not as computationally efficient as they could be because efficiency is sometimes sacrificed here for simplicity and accessibility.</p>
<p>The simulations in this chapter assume the following imports from NumPy, SciPy, and matplotlib.</p>
<div class="cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<section id="deterministic-simulations">
<span id="id2"></span><h2>9.1 Deterministic Simulations<a class="headerlink" href="#deterministic-simulations" title="Permalink to this heading">#</a></h2>
<p>Simulations with no random variables have fixed outcomes dictated by the code and input parameters. If these simulations are run multiple times using the same parameters, the outcomes of the simulations will be exactly identical. This is a category if simulations known as <em>deterministic simulations</em>. Even though many physical and chemical processes are driven by randomness, such as the random movements and collisions of molecules, they can often still be simulated deterministically because a large number of molecules can make the randomness conform to predictable statistical behavior. This is the case with Nuclear Magnetic Resonance (NMR) splitting patters and chemical kinetics among many others.</p>
<section id="nuclear-magnetic-resonance-splitting">
<span id="id3"></span><h3>9.1.1 Nuclear Magnetic Resonance Splitting<a class="headerlink" href="#nuclear-magnetic-resonance-splitting" title="Permalink to this heading">#</a></h3>
<p id="index-0">The splitting patters observed in <span class="math notranslate nohighlight">\(^1\)</span>H NMR spectra are typically generated by neighboring protons possessing spins of +1/2 or –1/2 which alter the magnetic field around the observed proton. Even though the signs of the neighboring protons are random, the sample contains such a large number of molecules that the ratio should be quite close to the theoretical value of approximately 1:1. As a result, we can simulate the splitting patterns generated in <span class="math notranslate nohighlight">\(^1\)</span>H NMR spectra deterministically by splitting all peaks into 1:1 doublets for every neighboring proton.</p>
<p>A recursive function is defined below that generates the splitting pattern generated by equivalent protons. The function takes in the chemical shift of the peak(s) (<code class="docutils literal notranslate"><span class="pre">peaks</span></code>), the number of equivalent neighboring protons (<code class="docutils literal notranslate"><span class="pre">n</span></code>), the coupling constant (<code class="docutils literal notranslate"><span class="pre">J</span></code>) in Hz, and the frequency of observation (<code class="docutils literal notranslate"><span class="pre">freq</span></code>) in MHz; and it returns a list of the split peaks in ppm. Each time the function is called, it splits the existing peak(s) into doublets, and the function is then called again if more splits are necessary due to multiple equivalent neighboring protons. The function below also includes validity checks to ensure the user-provided parameters are what the function expects.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;(list, int, float, freq=num) -&gt; list</span>
<span class="sd">    Takes in a list of peak ppm values for a single </span>
<span class="sd">    resonance(peaks),the number of identical neighboring </span>
<span class="sd">    protons(n), the coupling constant (J) in Hz, and the </span>
<span class="sd">    frequency of observation (freq) in MHz and returns a </span>
<span class="sd">    list of ppm values for all peaks in the splitting pattern.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># check validity of input values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">peaks</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: n must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="c1"># split the peak(s)</span>
    <span class="n">J_ppm</span>  <span class="o">=</span> <span class="n">J</span> <span class="o">/</span> <span class="n">freq</span>
    <span class="n">new_peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="n">new_peaks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">peak</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">J_ppm</span><span class="p">,</span> <span class="n">peak</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">J_ppm</span><span class="p">])</span>
        
    <span class="n">n</span> <span class="o">=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># perform next split or return result</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">new_peaks</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_peaks</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">split</span><span class="p">(</span><span class="mf">1.00</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="mf">3.4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1.0085000000000002, 1.0, 1.0, 0.9915]
</pre></div>
</div>
</div>
</div>
<p>In the above example, a peak at 1.00 ppm has two neighboring protons that couple with it at 3.4 Hz, and the sample is observed at 400 MHz. There are four resulting peaks in the output list, but two peaks are at the same chemical shift of 1.00 ppm. This results in three peaks with the peak at 1.00 ppm being twice the magnitude as the other two. We can visualize this by binning the peaks and generating a line plot.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The simulated NMR spectrum can also be plotted using the <code class="docutils literal notranslate"><span class="pre">plt.stem()</span></code> function.</p>
</div>
</aside>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">signal</span><span class="p">,</span> <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">split</span><span class="p">([</span><span class="mf">1.00</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="mf">6.8</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ppm</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">signal</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/12884bfb3277f78293f7976a7dbde311a155006b005aa987c6d50c885be03009.svg" src="../../_images/12884bfb3277f78293f7976a7dbde311a155006b005aa987c6d50c885be03009.svg" /></div>
</div>
<p>If there are multiple inequivalent groups of neighboring proton, this often results in more complex splitting patters due to additional protons and additional coupling constants. This can be simulated by nesting the <code class="docutils literal notranslate"><span class="pre">split()</span></code> function and providing the different coupling constants. Below, we simulate a splitting pattern for a proton coupled with two protons with J = 9.8 Hz and another proton with J = 10.8. This generates a doublet of triplets.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">signal</span><span class="p">,</span> <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">split</span><span class="p">([</span><span class="mf">1.00</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>  <span class="n">J</span><span class="o">=</span><span class="mf">10.8</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="mf">9.8</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ppm</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">signal</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Chemical Shift, ppm&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/17159d5ab68de4931089b34caeac5e38444d710de2f23c8ee4da541802712e5c.svg" src="../../_images/17159d5ab68de4931089b34caeac5e38444d710de2f23c8ee4da541802712e5c.svg" /></div>
</div>
</section>
<section id="single-step-stepwise-chemical-kinetics">
<span id="id4"></span><h3>9.1.2 Single-Step Stepwise Chemical Kinetics<a class="headerlink" href="#single-step-stepwise-chemical-kinetics" title="Permalink to this heading">#</a></h3>
<p id="index-1">Another phenomenon that can be simulated deterministically is the progress of a chemical reaction with respect to time. Many chemical reactions slow over the course of the reaction as the result of diminishing reactant concentrations. This occurs when reaction rates are dependent on the concentration of at least one reactant, and as the reaction progresses, starting material is consumed slowing the reaction.</p>
<p>One method for simulating this phenomenon is to incrementally calculate the rate of the chemical reaction at various points in the reaction based on the current concentrations. That is, at each small time step of the reaction, use the concentration(s) to calculate the current reaction rate and then increased/decreased the reaction concentrations by the amount calculated.</p>
<p>For example, we can simulate the following single-step chemical reaction of A <span class="math notranslate nohighlight">\(\rightarrow\)</span> P. Because this is an elementary step, the rate law is derivable from the stoichiometry where rate is M/s, <span class="math notranslate nohighlight">\(k_{rxn}\)</span> is the rate constant, and [A] is the concentration of A in molarity (M).</p>
<div class="math notranslate nohighlight">
\[ Rate=k_{rxn}[A]  \]</div>
<p>To keep the math simple, we will make each step in the reaction one second. That way, if the rate is 0.1 M/s, we can simply subtract 0.1 M for one second of reaction. Let us choose a <em>k</em> = 0.05 s<span class="math notranslate nohighlight">\(^{-1}\)</span> and an initial [A] = 1.00 M. Therefore, the rate = (0.05 s<span class="math notranslate nohighlight">\(^{-1}\)</span>)(1.00 M) = 0.05 M/s, so the concentration of A should decrease by 0.05 M in the first second giving us 0.95 M. Now the rate of reaction is (0.05 s<span class="math notranslate nohighlight">\(^{-1}\)</span>)(0.95 M) = 0.0475 M/s, so we now subtract 0.0475 M from [A] for the next second of reaction to get 0.903 M. This continues for the entire duration of the simulation. Code for executing this process is shown below. A <code class="docutils literal notranslate"><span class="pre">for</span></code> loop runs the above process for each second of the simulation and records the new concentrations of A and P in NumPy arrays via assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1.00</span><span class="p">,</span> <span class="mf">0.00</span> <span class="c1"># molarity, M</span>
<span class="n">k</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 1/s for a first-order reaction </span>
<span class="n">length</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># length of simulation in seconds </span>
<span class="n">time</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># create arrays to hold calculated concentrations</span>
<span class="n">A_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">P_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># simulation</span>
<span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">time</span><span class="p">:</span>
    <span class="c1"># record concentration</span>
    <span class="n">A_conc</span><span class="p">[</span><span class="n">sec</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
    <span class="n">P_conc</span><span class="p">[</span><span class="n">sec</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>
    <span class="c1"># recalculate rate</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">A</span>
    <span class="c1"># recalculate new concentration</span>
    <span class="n">A</span> <span class="o">-=</span> <span class="n">rate</span>
    <span class="n">P</span> <span class="o">+=</span> <span class="n">rate</span>
</pre></div>
</div>
</div>
</div>
<p>You may be wondering why the first lines of code in the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop records the concentrations instead of first decreasing them. This is because we need to record the initial concentration first before recalculating them. The next iteration will record the new concentrations before again recalculating rates and concentrations. Below is a plot of the simulation results.</p>
<div class="cell docutils container" id="index-2">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># step size</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">A_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">P_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Concentration, M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/d578e9cb26ff930cdb629ee697a3f308f44f2460ea88220bc78d8077c1306df4.svg" src="../../_images/d578e9cb26ff930cdb629ee697a3f308f44f2460ea88220bc78d8077c1306df4.svg" /></div>
</div>
<p>We can overlay this plot with the theoretical values using the integrated first-order rate law below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">A_theor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">P_theor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="n">A_theor</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">A_conc</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">P_conc</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Concentration, M&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A_theor</span><span class="p">,</span> <span class="s1">&#39;C0o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A Theoretical&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P_theor</span><span class="p">,</span> <span class="s1">&#39;C1p&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P Theoretical&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/ce737bcd3e747cb0cb2f67440d7316d046e879c4b53f009f37eac85c7d5dbda2.svg" src="../../_images/ce737bcd3e747cb0cb2f67440d7316d046e879c4b53f009f37eac85c7d5dbda2.svg" /></div>
</div>
<p>The theoretical equation and simulation results are in good agreement. A closer inspection of the two shows a slight discrepancy between the two which is most noticeable earlier in the simulation. This is because the simulation only adjusts the rate every second while the theoretical equation can be thought of as recalculating the rate for infinitely small increments. A more accurate method of performing kinetic simulations is presented in <a class="reference internal" href="#id6"><span class="std std-ref">section 9.1.4</span></a>.</p>
</section>
<section id="multistep-stepwise-chemical-kinetics">
<span id="id5"></span><h3>9.1.3 Multistep Stepwise Chemical Kinetics<a class="headerlink" href="#multistep-stepwise-chemical-kinetics" title="Permalink to this heading">#</a></h3>
<p>If we have a well-established theoretical equation for the above reaction of A <span class="math notranslate nohighlight">\(\rightarrow\)</span> P, why do we need the simulation? With this methodology, we can simulate more complicated reaction mechanisms, such as the multistep reaction below, even if we do not have the theoretical rate law in hand.</p>
<div class="math notranslate nohighlight">
\[ A \underset{k_{r1}}{\stackrel{k_1}{\rightleftharpoons}} I \]</div>
<div class="math notranslate nohighlight">
\[ I + B \underset{k_{r2}}{\stackrel{k_2}{\rightleftharpoons}} P \]</div>
<p>In this reaction, starting material A converts to intermediate I in the first step followed by starting material B combining with I to form the product P. Both of these steps are reversible, so there are four rate constants. The code and output of the simulation are below. Unlike the previous simulation, the simulation below appends values to lists (e.g., <code class="docutils literal notranslate"><span class="pre">A_conc</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A_conc</span><span class="p">,</span> <span class="n">B_conc</span><span class="p">,</span> <span class="n">I_conc</span><span class="p">,</span> <span class="n">P_conc</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>  <span class="c1"># initial conc, M</span>
<span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">kr2</span> <span class="o">=</span> <span class="mf">0.091</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.01</span> <span class="c1"># rate const</span>
<span class="n">length</span> <span class="o">=</span> <span class="mi">200</span>

<span class="c1"># the simulation</span>
<span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="n">A_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">I_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">B_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">P_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="c1"># recalculate rates</span>
    <span class="n">rate_1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">A</span>
    <span class="n">rate_r1</span> <span class="o">=</span> <span class="n">kr1</span> <span class="o">*</span> <span class="n">I</span>
    <span class="n">rate_2</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">I</span>
    <span class="n">rate_r2</span> <span class="o">=</span> <span class="n">kr2</span> <span class="o">*</span> <span class="n">P</span>
    <span class="c1">#recalculate concentrations after next time increment</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">rate_1</span> <span class="o">+</span> <span class="n">rate_r1</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">rate_1</span> <span class="o">-</span> <span class="n">rate_2</span> <span class="o">-</span> <span class="n">rate_r1</span> <span class="o">+</span> <span class="n">rate_r2</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">rate_2</span> <span class="o">+</span> <span class="n">rate_r2</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="n">rate_2</span> <span class="o">-</span> <span class="n">rate_r2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">A_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">I_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">B_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">P_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Concentration, M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/2704bac11d42e540ea5c31397ef948e39f5cbc6c3488d5ff22e072c348a86be2.svg" src="../../_images/2704bac11d42e540ea5c31397ef948e39f5cbc6c3488d5ff22e072c348a86be2.svg" /></div>
</div>
<p>A word of caution regarding the above simulations - if the rate constants are increased enough, oscillating behavior and negative concentrations will be observed… the latter of which is clearly wrong. This is because the simulation fails to recalculation the rates fast enough for the simulation, but this can be remedied by decreasing the step size.</p>
</section>
<section id="chemical-kinetics-and-odeint">
<span id="id6"></span><h3>9.1.4 Chemical Kinetics and ODEINT<a class="headerlink" href="#chemical-kinetics-and-odeint" title="Permalink to this heading">#</a></h3>
<p>Another approach to performing the above kinetic simulations is to integrate the differential equations. For an introduction to integrating differential equations, see <a class="reference internal" href="../chapter_08/chap_08_notebook.html#id22"><span class="std std-ref">section 8.4.4</span></a>. Below we will simulate a two step reaction where the first step is reversible. Because the following are the elementary steps, the rate equations can be inferred from the reaction stoichiometry.</p>
<div class="math notranslate nohighlight">
\[ A \underset{k_{r1}}{\stackrel{k_1}{\rightleftharpoons}} B \stackrel{k_2}\rightarrow P\]</div>
<p>The three differential equations tracking the concentrations of A, B, and P are shown below where <span class="math notranslate nohighlight">\(k_1\)</span> and <span class="math notranslate nohighlight">\(k_{r1}\)</span> are the forward and reverse rate constants, respectively, for the first step and <span class="math notranslate nohighlight">\(k_2\)</span> is the rate constant for the second step.</p>
<div class="math notranslate nohighlight">
\[ \frac{d[A]}{dt} = k_1[A] + k_{r1}[B] \]</div>
<div class="math notranslate nohighlight">
\[ \frac{d[B]}{dt} = k_1[A] + k_2[B] - k_{r1}[B]\]</div>
<div class="math notranslate nohighlight">
\[ \frac{d[P]}{dt} = k_2[B] \]</div>
<p>As is done in <a class="reference internal" href="../chapter_08/chap_08_notebook.html#id22"><span class="std std-ref">section 8.4.4</span></a>, a Python function is created containing the differential equations, but in contrast to chapter 8, the differential equation for d[P]/dt is also included in the Python function instead  of calculating [P] after the integration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">k1</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span>
<span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">P0</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="n">conc</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">conc</span>
    <span class="n">dAdt</span> <span class="o">=</span> <span class="o">-</span><span class="n">k1</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">kr1</span> <span class="o">*</span> <span class="n">B</span>
    <span class="n">dBdt</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">A</span> <span class="o">-</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span> <span class="o">-</span> <span class="n">kr1</span> <span class="o">*</span> <span class="n">B</span>
    <span class="n">dPdt</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span>
    
    <span class="k">return</span> <span class="n">dAdt</span><span class="p">,</span> <span class="n">dBdt</span><span class="p">,</span> <span class="n">dPdt</span>
</pre></div>
</div>
</div>
</div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">odeint()</span></code> function only takes the initial concentration (<code class="docutils literal notranslate"><span class="pre">A0</span></code>, <code class="docutils literal notranslate"><span class="pre">B0</span></code>, and <code class="docutils literal notranslate"><span class="pre">P0</span></code>) as a single argument, they need to be placed in a tuple.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A_t</span><span class="p">,</span> <span class="n">B_t</span><span class="p">,</span> <span class="n">P_t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">rates</span><span class="p">,</span> <span class="p">(</span><span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">P0</span><span class="p">),</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A_t</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">B_t</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P_t</span><span class="p">,</span> <span class="s1">&#39;-.&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;[X], M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/3b3d521706ceeecb9b994ee774f88ca86e6af75c067545f6888872203eda9582.svg" src="../../_images/3b3d521706ceeecb9b994ee774f88ca86e6af75c067545f6888872203eda9582.svg" /></div>
</div>
</section>
</section>
<section id="stochastic-simulations">
<span id="id7"></span><h2>9.2 Stochastic Simulations<a class="headerlink" href="#stochastic-simulations" title="Permalink to this heading">#</a></h2>
<p id="index-3">Unlike the deterministic simulations above, if the same code for a stochastic simulation is run multiple times, the results will vary at least slightly, though the overall patterns should be similar. This is because the outcome of stochastic simulations is determined by (pseudo)random number generators. It is as if the results of the simulation are dictated by the flip of a coin or roll of a die. This analogy is so good that rolling dice repeatedly can simulate radioactive decay kinetics among other things. Rolling a die thousands of times is tedious, so we will use NumPy’s <code class="docutils literal notranslate"><span class="pre">random</span></code> module to generate random values for the simulations.</p>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a random component to some of the following code, so exact results may vary.</p>
</div>
</aside>
<section id="radioactive-decay">
<span id="id8"></span><h3>9.2.1 Radioactive Decay<a class="headerlink" href="#radioactive-decay" title="Permalink to this heading">#</a></h3>
<p id="index-4">Radioactive decay is a random process, so logically it can be simulated as such. Every radioactive atom has a fixed probability of decaying each second just like a die has a fixed probability of rolling a one. In the simulation below, a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop is used for each second or step of the simulation, and a random number generator is used in each step to decide how many atoms decay. The <code class="docutils literal notranslate"><span class="pre">binomial()</span></code> method is used here to generate a series of zeros and ones with a set probability of generating a one. In this simulation, a one signifies a decaying atom. These decayed atoms are tallied and subtracted from the current number of remaining atoms, and this value is recorded in the <code class="docutils literal notranslate"><span class="pre">atoms_remaining</span></code> variable.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_remove-input docutils container">
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">starting_atoms</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">length</span> <span class="o">=</span> <span class="mi">10000</span>  <span class="c1"># length of simulation</span>
<span class="n">num_atoms</span> <span class="o">=</span> <span class="n">starting_atoms</span>
<span class="n">atoms_remaining</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="n">atoms_remaining</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_atoms</span><span class="p">)</span>
    <span class="c1"># &quot;rolls&quot; dice and tallies up number of zeros</span>
    <span class="n">decays</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_atoms</span><span class="p">)</span>
    <span class="n">decayed_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">decays</span><span class="p">)</span>
    <span class="c1"># deduct decayed nuclei from the total</span>
    <span class="n">num_atoms</span> <span class="o">-=</span> <span class="n">decayed_count</span>

<span class="c1"># convert list to array    </span>
<span class="n">atoms_remaining</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">atoms_remaining</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The simulation results stored in the <code class="docutils literal notranslate"><span class="pre">atoms_remaining</span></code> array can be plotted along with the first-order integrated rate law to see how the two compare. Being that there is a 1/1000 probability in the above simulation of each atom generating a one (decay), the rate constant (<span class="math notranslate nohighlight">\(k\)</span>) is 0.001 s<span class="math notranslate nohighlight">\(^{-1}\)</span>. For ease of viewing, only twenty data points from the simulation are plotting below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot of simulation</span>
<span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">atoms_remaining</span><span class="p">[::</span><span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulation Results&#39;</span><span class="p">)</span>
<span class="c1"># plot of theoretical rate law</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">starting_atoms</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">t</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Theoretical Model&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Atoms Remaining&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/3d5db8273a275ab034dca5d4635f562a811c59811e849e1cebae77abe4f622ee.svg" src="../../_images/3d5db8273a275ab034dca5d4635f562a811c59811e849e1cebae77abe4f622ee.svg" /></div>
</div>
<p>The simulation and theoretical model are in good but not perfect agreement. The deviation is a result of the simulation using random numbers and only simulating a relatively small number of molecules. If this simulation were run with increasingly larger number of molecules, the results are expected to converge on the theoretical prediction.</p>
</section>
<section id="confidence-intervals">
<span id="id9"></span><h3>9.2.2 Confidence Intervals<a class="headerlink" href="#confidence-intervals" title="Permalink to this heading">#</a></h3>
<p id="index-5">Uncertainty is a part of all data, and uncertainty around a repeatedly measured and calculated value is sometimes represented in the form of a 95% confidence interval (CI). This is the interval around the mean that has a 95% chance of containing the true value. Another way of describing 95% CI is that if we were to repeatedly collect a data set and calculate the 95% CI, the true value should be, statistically speaking, inside the confidence interval 95% of the time. Performing these experiments would be tedious, but this can be simulated in Python relatively easily.</p>
<p>The equation for calculating the 95% CI is shown below where <span class="math notranslate nohighlight">\(\bar{x}\)</span> is the average value in a set of repeated measurements, <span class="math notranslate nohighlight">\(s\)</span> is the standard deviation (corrected), <span class="math notranslate nohighlight">\(t\)</span> is the statistical <span class="math notranslate nohighlight">\(t\)</span> value from a table, and <span class="math notranslate nohighlight">\(N\)</span> is the degrees of freedom. For 20 samples per set, <span class="math notranslate nohighlight">\(t\)</span> = 2.09 and <span class="math notranslate nohighlight">\(N\)</span> = 19.</p>
<div class="math notranslate nohighlight">
\[ 95\%CI = \bar{x} \pm \frac{ts}{\sqrt{N}} \]</div>
<p>We can simulated the data collection by picking a true value and generating twenty samples by adding random error to twenty copies of the true value. Using the simulated data set, the 95% CI can be calculated, and we can test whether or not the true value is inside the CI. If we repeated this procedure numerous times recording the success or failure of the true value being inside the CI, we can calculate the success rate as demonstrated below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trials</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">2.09</span>
<span class="n">true</span> <span class="o">=</span> <span class="mf">6.2</span>  <span class="c1"># true value</span>
<span class="c1"># number of times mean inside 95% CI</span>
<span class="n">in_interval</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="c1"># create synthetic data</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">true</span> <span class="o">+</span> <span class="p">(</span><span class="n">error</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    
    <span class="c1"># calculate the 95% CI</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">CI_95</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">-</span> <span class="n">CI_95</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">+</span> <span class="n">CI_95</span>
    
    <span class="c1"># determine if true values is inside 95% CI</span>
    <span class="k">if</span> <span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">true</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">:</span>
        <span class="n">in_interval</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">100</span> <span class="o">*</span> <span class="n">in_interval</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>94.85
</pre></div>
</div>
</div>
</div>
<p>The above simulation finds that almost 95% of the time the true value is inside the 95% CI, which is pretty close to what we expected. If this simulation is repeated, you will likely observe that the values are very often slightly below the expected 95%. This is the result of smaller data sets and should be closer to the theoretical value with increasing data set size.</p>
</section>
<section id="random-flight-polymer">
<span id="id10"></span><h3>9.2.3 Random Flight Polymer<a class="headerlink" href="#random-flight-polymer" title="Permalink to this heading">#</a></h3>
<p id="index-6">Polymers are long chains of repeating units called monomers. These chains can easily extend for thousands of monomers and wind around in 3D space in seemingly random fashions. A single polymer chain can be made of a single type of monomer or multiple types and can be of varying lengths, but for the following polymer simulation, we will work with polymers of a fixed number of monomers and ignore the monomer types.</p>
<p>One model for polymer conformation is a <em>random flight polymer</em> which assumes that the conformation of the polymer is entirely random. We can simulate a random flight polymer through a <em>random walk</em> by making each subsequent segment of polymer extend in a random direction and distance. For simplicity, we will simulate the polymer in only two dimensions, but this simulation can be expanded to a third dimension. The random element of the simulation is provided by a NumPy random number generator which generates a random length and direction for each new segment.</p>
<p>The general procedure for the following simulation is to start the polymer chain at coordinate (0, 0), and for each new segment, add a random value to the x-coordinate of the previous polymer end and another random value to the y-coordinate. Each new coordinate is then appended to a list of coordinates (<code class="docutils literal notranslate"><span class="pre">coords</span></code>) for analysis and visualization. This simulation is coded below. The random values are floats from [-1, 1). NumPy does not provide a function for generating this range, so we can modify the [0,1) range from the <code class="docutils literal notranslate"><span class="pre">random()</span></code> method by subtracting 0.5 and multiplying by 2.</p>
<div class="cell tag_remove-input docutils container">
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">segments</span> <span class="o">=</span> <span class="mi">3000</span>
<span class="n">coords</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
    
<span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Position(x), au&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Position(y), au&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/0de6b0c0a29b31eb929f24fc780097f4373180304e769556e8905297ca215f86.svg" src="../../_images/0de6b0c0a29b31eb929f24fc780097f4373180304e769556e8905297ca215f86.svg" /></div>
</div>
<p>The results of the simulation show a polymer strand winding around in a seemingly random fashion. If we rerun the above simulation, a different looking polymer conformation will be generated.</p>
</section>
</section>
<section id="further-reading">
<h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Downey, Allen Modeling and Simulation in Python. Book in progress. <a class="github reference external" href="https://github.com/AllenDowney/ModSimPy">AllenDowney/ModSimPy</a> (free resource)</p></li>
<li><p>Weiss, C. J. Introduction to Stochastic Simulations for Chemical and Physical Processes: Principles and Applications. <em>J. Chem. Educ.</em> <strong>2017,</strong> 94 (12), 1904–1910. <a class="reference external" href="https://doi.org/10.1021/acs.jchemed.7b00395">https://doi.org/10.1021/acs.jchemed.7b00395</a></p></li>
<li><p>For examples of chemical kinetics scenarios to model, see: Bentenitis, N. A Convenient Tool for the Stochastic Simulation of Reaction Mechanisms. <em>J. Chem. Educ.</em> <strong>2008,</strong> 85 (8), 1146−1150. <a class="reference external" href="https://doi.org/10.1021/ed085p1146">https://doi.org/10.1021/ed085p1146</a></p></li>
</ol>
</section>
<section id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<p>Complete the following exercises in a Jupyter notebook. Any data file(s) refered to in the problems can be found in the <a class="reference external" href="https://github.com/weisscharlesj/SciCompforChemists/tree/master/notebooks">data</a> folder in the same directory as this chapter’s Jupyter notebook. Alternatively, you can download a zip file of the data for this chapter from <a class="reference external" href="https://github.com/weisscharlesj/data_SciCompforChem">here</a> by selecting the appropriate chapter file and then clicking the <strong>Download</strong> button.</p>
<ol class="arabic">
<li><p>Using <code class="docutils literal notranslate"><span class="pre">scipy.integrate.odeint()</span></code> and a differential equation, plot the concentration of starting material A with respect to time for a third-order reaction.</p></li>
<li><p>Create a simulation of the following single-step reaction and overlay it with the appropriate integrated rate law. The rate constant is 0.28 M<span class="math notranslate nohighlight">\(^{-1}\)</span>s<span class="math notranslate nohighlight">\(^{-1}\)</span>. Feel free to start with code from this chapter and modify it as needed.</p>
<div class="math notranslate nohighlight">
\[ 2A \rightarrow P \]</div>
</li>
<li><p>Plot the concentrations of A, B, C, and P with respect to time for the following three-step, non-reversible mechanism. The initial concentrations and rate constants are in the table below.</p>
<div class="math notranslate nohighlight">
\[ A \rightarrow B \rightarrow C \rightarrow P  \]</div>
<table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Step</p></th>
<th class="head text-center"><p>Specie</p></th>
<th class="head text-center"><p>[Specie]<span class="math notranslate nohighlight">\(_0\)</span>, M</p></th>
<th class="head text-center"><p>Rate Constant, s<span class="math notranslate nohighlight">\(^{-1}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>1</p></td>
<td class="text-center"><p>A</p></td>
<td class="text-center"><p>1.50</p></td>
<td class="text-center"><p>0.8</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>2</p></td>
<td class="text-center"><p>B</p></td>
<td class="text-center"><p>0.00</p></td>
<td class="text-center"><p>0.4</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>3</p></td>
<td class="text-center"><p>C</p></td>
<td class="text-center"><p>0.00</p></td>
<td class="text-center"><p>0.3</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>–</p></td>
<td class="text-center"><p>P</p></td>
<td class="text-center"><p>0.00</p></td>
<td class="text-center"><p>–</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Simulate the following chemical equilibrium where the forward rate is described by Rate<span class="math notranslate nohighlight">\(_f\)</span> = (1.3 × 10<span class="math notranslate nohighlight">\(^{-2}\)</span> M<span class="math notranslate nohighlight">\(^{-1}\)</span>s<span class="math notranslate nohighlight">\(^{-1}\)</span>)[A]<span class="math notranslate nohighlight">\(^2\)</span> and the reverse rate is described by Rate<span class="math notranslate nohighlight">\(_r\)</span> = (6.2 × 10<span class="math notranslate nohighlight">\(^{-3}\)</span> s<span class="math notranslate nohighlight">\(^{-1}\)</span>)[B].</p>
<div class="math notranslate nohighlight">
\[ 2A \underset{k_r}{\stackrel{k_f}{\rightleftharpoons}} B \]</div>
<p>Use a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to simulate each second of reaction by calculating the rates and increasing/decreasing each concentration appropriately. Record the concentrations in lists and plot the results. Start with 2.20 M of A and 1.72 M B and run the simulation for at least 200 seconds. Notice that the rates are in M/s.</p>
</li>
<li><p>In <a class="reference internal" href="#id5"><span class="std std-ref">section 9.1.3</span></a>, a two-step, reversible reaction is simulated. If the rate constant k<span class="math notranslate nohighlight">\(_{r1}\)</span> is decreased to 0.001 s<span class="math notranslate nohighlight">\(^{-1}\)</span>, what effect on the reaction do you anticipate? Simulate this to see if your prediction is correct.</p></li>
<li><p>Simulate two competing, first-order reactions of starting material A forming product P<span class="math notranslate nohighlight">\(_1\)</span> and P<span class="math notranslate nohighlight">\(_2\)</span> and plot the resulting concentrations of both products versus time.</p>
<div class="math notranslate nohighlight">
\[ P_1 \stackrel{k_1}{\leftarrow} A \stackrel{k_2}\rightarrow P_2 \]</div>
<p>Use k<span class="math notranslate nohighlight">\(_1\)</span> = 0.02 M/s and k<span class="math notranslate nohighlight">\(_2\)</span> = 0.04 M/s and start with 2.00 M A. What do you predict the plot of concentration versus time to look like and the ratio of products to be? Does your simulation agree?</p>
</li>
<li id="index-7"><p>Polymers that consist of two or more different monomers are known as copolymers. Simulate an addition copolymer consisting of two monomers: ethylene (28.06 g/mol) and styrene (104.16 g/mol) with a fixed length of a thousand units. Given the molecular weights of the two monomers above, calculate the weights for a thousand simulated polymer strands and generate a histograms of the frequency versus weight. Hint: try using the <code class="docutils literal notranslate"><span class="pre">binomial()</span></code> method with <code class="docutils literal notranslate"><span class="pre">p=0.5</span></code> and treat a zero as one monomer and a one is   the other.</p>
</li>
<li id="index-8"><p>Block copolymers are polymers where multiple monomer types are clustered along the polymer chain instead of being randomly dispersed. These clusters are called blocks which may be of random lengths as the polymer switches between monomer types. An example is shown below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-A-A-A-A-A-A-A-B-B-B-B-B-B-A-A-A-A-B-B-B-A-A-A-A-A-
</pre></div>
</div>
<p>Simulate a block copolymer consisting of two monomers with a total length of a hundred monomer units.</p>
<p>Hint: Append monomers (0 or 1) to a list inside a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, and use a method such as <code class="docutils literal notranslate"><span class="pre">binomial()</span></code> to decide when to toggle between monomers types. Use <code class="docutils literal notranslate"><span class="pre">mono</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">mono</span></code> to make the switch.</p>
</li>
<li><p>The random flight polymer simulation presented in section 9.2.3 uses a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. As discussed in chapter 4, one of the virtues of NumPy is that it often avoids the computationally inefficient <code class="docutils literal notranslate"><span class="pre">for</span></code> loops. Below is the same simulation written in a single line of code leveraging the power of NumPy arrays. Briefly explain what it is doing and why it works.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Proteins are nature polymers consisting of twenty common monomers called amino acids. Simulate a random protein strand of a thousand units long using the <code class="docutils literal notranslate"><span class="pre">integers()</span></code> method and a Python dictionary or list containing the single letter amino acid codes.</p></li>
<li><p>Confidence intervals</p>
<p>a) Convert the code for calculating a 95% confidence interval in <a class="reference internal" href="#id9"><span class="std std-ref">section 9.2.2</span></a> to a Python function that accepts the number of samples as the one argument and returns the percentage of the time the true value is inside the confidence interval. You will need to look up t values and generate a dictionary that converts degrees of freedom (N) to t values.</p>
<p>b) Using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, calculate the percentage of the time the true value is in the 95% confidence interval for each of the sample sizes in the above dictionary and plot the results. Describe the trend.</p>
</li>
<li><p>Simulate the diffusion of molecules along a single axis. Start all molecules at zero, and for each step of the simulation, add a random number, positive or negative, to each value in the array. Plot the results in a histogram.</p></li>
<li><p>Using the function from <a class="reference internal" href="#id3"><span class="std std-ref">section 9.1.1</span></a>, simulate the splitting pattern for the tertiary proton in isopropyl alcohol ((CH<span class="math notranslate nohighlight">\(_3\)</span>)<span class="math notranslate nohighlight">\(_2\)</span>CHOH). In CDCl<span class="math notranslate nohighlight">\(_3\)</span>, this proton is observed at 3.82 ppm with a coupling constant of 6 Hz. Assume no coupling with the hydroxyl proton is observed.</p></li>
<li><p>The law of large numbers indicates that as the number of trials increases, the observed average should overall converge on the statistical average. For example, when rolling a six-sided die, all numbers are equally probable to land up, so if we roll a number of dice, the average of all the numbers is expected to be around 3.5 (i.e., (1 + 2 + 3 + 4 + 5 + 6)/6 = 3.5). Using the <code class="docutils literal notranslate"><span class="pre">integers()</span></code> method, simulate the rolling of between two and five thousand, six-sided dice and plot the resulting average number versus the number of dice rolled. Include at least a hundred data points in your plot and label your axes.</p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks/chapter_09"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="../chapter_08/chap_08_notebook.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Chapter 8: Mathematics</p>
      </div>
    </a>
    <a class="right-next"
       href="../chapter_10/chap_10_notebook.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 10: Plotting with Seaborn</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#deterministic-simulations">9.1 Deterministic Simulations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#nuclear-magnetic-resonance-splitting">9.1.1 Nuclear Magnetic Resonance Splitting</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#single-step-stepwise-chemical-kinetics">9.1.2 Single-Step Stepwise Chemical Kinetics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multistep-stepwise-chemical-kinetics">9.1.3 Multistep Stepwise Chemical Kinetics</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#chemical-kinetics-and-odeint">9.1.4 Chemical Kinetics and ODEINT</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#stochastic-simulations">9.2 Stochastic Simulations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#radioactive-decay">9.2.1 Radioactive Decay</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#confidence-intervals">9.2.2 Confidence Intervals</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#random-flight-polymer">9.2.3 Random Flight Polymer</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#further-reading">Further Reading</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">Exercises</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Charles J. Weiss
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2017-2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
<div class="extra_footer">
  Scientific Computing for Chemists with Python is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
</div>
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>