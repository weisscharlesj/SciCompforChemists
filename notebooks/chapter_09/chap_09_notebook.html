
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chapter 9: Simulations &#8212; Scientific Computing for Chemists with Python</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Chapter 10: Plotting with Seaborn" href="../chapter_10/chap_10_notebook.html" />
    <link rel="prev" title="Chapter 8: Mathematics" href="../chapter_08/chap_08_notebook.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Scientific Computing for Chemists with Python</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Scientific Computing for Chemists with Python
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_00/chap_00_notebook.html">
   Chapter 0: Python &amp; Jupyter Notebooks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_01/chap_01_notebook.html">
   Chapter 1: Basic Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_02/chap_02_notebook.html">
   Chapter 2: Intermediate Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_03/chap_03_notebook.html">
   Chapter 3: Plotting with Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_04/chap_04_notebook.html">
   Chapter 4: NumPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_05/chap_05_notebook.html">
   Chapter 5: Pandas
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_06/chap_06_notebook.html">
   Chapter 6: Signal &amp; Noise
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_07/chap_07_notebook.html">
   Chapter 7: Image Processing &amp; Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_08/chap_08_notebook.html">
   Chapter 8: Mathematics
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Chapter 9: Simulations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_10/chap_10_notebook.html">
   Chapter 10: Plotting with Seaborn
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_11/chap_11_notebook.html">
   Chapter 11: Nuclear Magnetic Resonance with NMRglue
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_12/chap_12_notebook.html">
   Chapter 12: Machine Learning using Scikit-Learn
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_13/chap_13.html">
   Chapter 13: Command Line &amp; Spyder
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org/">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notebooks/chapter_09/chap_09_notebook.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        <a class="issues-button"
            href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fnotebooks/chapter_09/chap_09_notebook.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/notebooks/chapter_09/chap_09_notebook.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deterministic-simulations">
   9.1 Deterministic Simulations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nuclear-magnetic-resonance-splitting">
     9.1.1 Nuclear Magnetic Resonance Splitting
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#single-step-stepwise-chemical-kinetics">
     9.1.2 Single-Step Stepwise Chemical Kinetics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multistep-stepwise-chemical-kinetics">
     9.1.3 Multistep Stepwise Chemical Kinetics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#chemical-kinetics-and-odeint">
     9.1.4 Chemical Kinetics and ODEINT
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#stochastic-simulations">
   9.2 Stochastic Simulations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#radioactive-decay">
     9.2.1 Radioactive Decay
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#confidence-intervals">
     9.2.2 Confidence Intervals
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#random-flight-polymer">
     9.2.3 Random Flight Polymer
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-reading">
   Further Reading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Chapter 9: Simulations</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#deterministic-simulations">
   9.1 Deterministic Simulations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#nuclear-magnetic-resonance-splitting">
     9.1.1 Nuclear Magnetic Resonance Splitting
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#single-step-stepwise-chemical-kinetics">
     9.1.2 Single-Step Stepwise Chemical Kinetics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multistep-stepwise-chemical-kinetics">
     9.1.3 Multistep Stepwise Chemical Kinetics
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#chemical-kinetics-and-odeint">
     9.1.4 Chemical Kinetics and ODEINT
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#stochastic-simulations">
   9.2 Stochastic Simulations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#radioactive-decay">
     9.2.1 Radioactive Decay
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#confidence-intervals">
     9.2.2 Confidence Intervals
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#random-flight-polymer">
     9.2.3 Random Flight Polymer
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-reading">
   Further Reading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="chapter-9-simulations">
<span id="id1"></span><h1>Chapter 9: Simulations<a class="headerlink" href="#chapter-9-simulations" title="Permalink to this headline">¶</a></h1>
<div class="cell tag_remove-input docutils container">
</div>
<p>Simulations are a major component of modern chemical research either in conjunction with experimental work or by itself. A <em>digital chemical simulation</em> is a representation or mimic of a physical or chemical process using a computer with enough detail that the results provide meaningful and useful insights into the real process. Simulations do not need represent every aspect of the real world as long as the omitted details do not reduce the accuracy or precision to a level that the simulation is no longer useful.</p>
<p>Modern chemical simulations are often quite complex and are performed with a range of free or commercial software that regrettably can obfuscate the underlying methods. This chapter aims to introduce simulations with simple methodologies that can be easily coded in Python, NumPy, and SciPy. These simulations are not designed for use in a research setting due to the low level of sophistication and do not represent the current state-of-art in the field of chemical simulations. Some of these simulations are also not as computationally efficient as they could be because efficiency is sometimes sacrificed here for simplicity and accessibility.</p>
<p>The simulations in this chapter assume the following imports from NumPy, SciPy, and matplotlib.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;frozen importlib._bootstrap&gt;:228: RuntimeWarning: scipy._lib.messagestream.MessageStream size changed, may indicate binary incompatibility. Expected 56 from C header, got 64 from PyObject
</pre></div>
</div>
</div>
</div>
<div class="section" id="deterministic-simulations">
<span id="id2"></span><h2>9.1 Deterministic Simulations<a class="headerlink" href="#deterministic-simulations" title="Permalink to this headline">¶</a></h2>
<p>Simulations with no random variables have fixed outcomes dictated by the code and input parameters. If these simulations are run multiple times using the same parameters, the outcomes of the simulations will be exactly identical. This is a category if simulations known as <em>deterministic simulations</em>. Even though many physical and chemical processes are driven by randomness, such as the random movements and collisions of molecules, they can often still be simulated deterministically because with a large number of molecules makes the randomness conform to predictable patterns. This is the case with Nuclear Magnetic Resonance (NMR) splitting patters and chemical kinetics among many others.</p>
<div class="section" id="nuclear-magnetic-resonance-splitting">
<span id="id3"></span><h3>9.1.1 Nuclear Magnetic Resonance Splitting<a class="headerlink" href="#nuclear-magnetic-resonance-splitting" title="Permalink to this headline">¶</a></h3>
<p>The splitting patters observed in <span class="math notranslate nohighlight">\(^1\)</span>H NMR spectra are typically generated by neighboring protons possessing spins of +1/2 or –1/2 which alter the magnetic field around the observed proton. Even though the signs of the neighboring protons are random, the sample contains such a large number of molecules that the ratio should be quite close to the theoretical value of approximately 1:1. As a result, we can simulate the splitting patterns generated in <span class="math notranslate nohighlight">\(^1\)</span>H NMR spectra deterministically by splitting all peaks into 1:1 doublets for every neighboring proton.</p>
<p>A recursive function is defined below that generates the splitting pattern generated by equivalent protons. The function takes in the chemical shift of the peak(s) (<code class="docutils literal notranslate"><span class="pre">peaks</span></code>), the number of equivalent neighboring protons (<code class="docutils literal notranslate"><span class="pre">n</span></code>), the coupling constant (<code class="docutils literal notranslate"><span class="pre">J</span></code>) in Hz, and the frequency of observation (<code class="docutils literal notranslate"><span class="pre">freq</span></code>) in MHz; and it returns a list of the split peaks in ppm. Each time the function is called, it splits the existing peak(s) into doublets, and the function is then called again if more splits are necessary due to multiple equivalent neighboring protons. The function below also includes validity checks to ensure the user-provided parameters are what the function expects.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">peaks</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">400</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;(list, int, float, freq=num) -&gt; list</span>
<span class="sd">    Takes in a list of peak ppm values for a single </span>
<span class="sd">    resonance(peaks),the number of identical neighboring </span>
<span class="sd">    protons(n), the coupling constant (J) in Hz, and the </span>
<span class="sd">    frequency of observation (freq) in MHz and returns a </span>
<span class="sd">    list of ppm values for all peaks in the splitting pattern.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># check validity of input values</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">peaks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">peaks</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: n must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="c1"># split the peak(s)</span>
    <span class="n">J_ppm</span>  <span class="o">=</span> <span class="n">J</span> <span class="o">/</span> <span class="n">freq</span>
    <span class="n">new_peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">:</span>
        <span class="n">new_peaks</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">peak</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">J_ppm</span><span class="p">,</span> <span class="n">peak</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">J_ppm</span><span class="p">])</span>
        
    <span class="n">n</span> <span class="o">=</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="c1"># perform next split or return result</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">new_peaks</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_peaks</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">split</span><span class="p">(</span><span class="mf">1.00</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="mf">3.4</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[1.0085000000000002, 1.0, 1.0, 0.9915]
</pre></div>
</div>
</div>
</div>
<p>In the above example, a peak at 1.00 ppm has two neighboring protons that couple with it at 3.4 Hz, and the sample is observed at 400 MHz. There are four resulting peaks in the output list, but two peaks are at the same chemical shift of 1.00 ppm. This results in three peaks with the one at 1.00 ppm being twice the magnitude as the other two. We can visualize this by binning the peaks and generating a line plot.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">signal</span><span class="p">,</span> <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">split</span><span class="p">([</span><span class="mf">1.00</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="mf">6.8</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ppm</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">signal</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fd0579a4bb0&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_8_1.svg" src="../../_images/chap_09_notebook_8_1.svg" /></div>
</div>
<p>If there are multiple inequivalent groups of neighboring proton, this often results in more complex splitting patters due to additional protons and additional coupling constants. This can be simulated by nesting the <code class="docutils literal notranslate"><span class="pre">split()</span></code> function and providing the different coupling constants. Below, we simulate a splitting pattern for a proton coupled with two protons with J = 9.8 Hz and another proton with J = 10.8. This generates a doublet of triplets.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">signal</span><span class="p">,</span> <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">split</span><span class="p">([</span><span class="mf">1.00</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>  <span class="n">J</span><span class="o">=</span><span class="mf">10.8</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="mf">9.8</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ppm</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">signal</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Chemical Shift, ppm&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;Chemical Shift, ppm&#39;)
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_10_1.svg" src="../../_images/chap_09_notebook_10_1.svg" /></div>
</div>
</div>
<div class="section" id="single-step-stepwise-chemical-kinetics">
<span id="id4"></span><h3>9.1.2 Single-Step Stepwise Chemical Kinetics<a class="headerlink" href="#single-step-stepwise-chemical-kinetics" title="Permalink to this headline">¶</a></h3>
<p>Another phenomenon that can be simulated deterministically is the progress of a chemical reaction with respect to time. Many chemical reaction slow over the course of the reaction as the result of diminishing reactant concentrations. This is because many reaction rates are dependent on the concentration of at least one staring material, and as the reaction progresses, starting material is consumed slowing the reaction.</p>
<p>One method for simulating this phenomenon is to incrementally calculate the rate of the chemical reaction at various points in the reaction based on the current concentrations. That is, at each small time step of the reaction, use the concentration(s) to calculate the current reaction rate and then increased/decreased the reaction concentrations by the amount calculated.</p>
<p>For example, we can simulate the following single-step chemical reaction of A <span class="math notranslate nohighlight">\(\rightarrow\)</span> P. Because this is an elementary step, the rate law is derivable from the stoichiometry where rate is M/s, <span class="math notranslate nohighlight">\(k_{rxn}\)</span> is the rate constant, and [A] is the concentration of A in molarity (M).</p>
<div class="math notranslate nohighlight">
\[ Rate=k_{rxn}[A]  \]</div>
<p>To keep the math simple, we will make each step in the reaction one second. That way, if the rate is 0.1 M/s, we can simply subtract 0.1 M for one second of reaction. Let us choose a <em>k</em> = 0.05 s<span class="math notranslate nohighlight">\(^{-1}\)</span> and an initial [A] = 1.00 M. Therefore, the rate = (0.05 s<span class="math notranslate nohighlight">\(^{-1}\)</span>)(1.00 M) = 0.05 M/s, so the concentration of A should decrease by 0.05 M in the first second giving us 0.95 M. Now the rate of reaction is (0.05 s<span class="math notranslate nohighlight">\(^{-1}\)</span>)(0.95 M) = 0.0475 M/s, so we now subtract 0.0475 M from [A] for the next second of reaction to get 0.903 M. This continues for the entire duration of the simulation. Code for executing this process is shown below. A <code class="docutils literal notranslate"><span class="pre">for</span></code> loop runs the above process for each second of the simulation and records the new concentrations of A and P in NumPy arrays via assignment.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1.00</span><span class="p">,</span> <span class="mf">0.00</span> <span class="c1"># molarity, M</span>
<span class="n">k</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 1/s for a first-order reaction </span>
<span class="n">length</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># length of simulation in seconds </span>
<span class="n">time</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># create arrays to hold calculated concentrations</span>
<span class="n">A_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">P_conc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># simulation</span>
<span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">time</span><span class="p">:</span>
    <span class="c1"># record concentration</span>
    <span class="n">A_conc</span><span class="p">[</span><span class="n">sec</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
    <span class="n">P_conc</span><span class="p">[</span><span class="n">sec</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span>
    <span class="c1"># recalculate rate</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">A</span>
    <span class="c1"># recalculate new concentration</span>
    <span class="n">A</span> <span class="o">-=</span> <span class="n">rate</span>
    <span class="n">P</span> <span class="o">+=</span> <span class="n">rate</span>
</pre></div>
</div>
</div>
</div>
<p>You may be wondering why the first lines of code in the <code class="docutils literal notranslate"><span class="pre">for</span></code> loop record the concentrations instead of first decreasing them. This is because we need to record the initial concentration first before recalculating them. The next iteration will record the new concentrations before again recalculating rates and concentrations. Below is a plot of the simulation results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">A_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">P_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Concentration, M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fd057afd700&gt;
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_14_1.svg" src="../../_images/chap_09_notebook_14_1.svg" /></div>
</div>
<p>We can overlay this plot with the theoretical values using the integrated first-order rate law below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">A_theor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">P_theor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="n">A_theor</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">A_conc</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A_sim&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">P_conc</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P_sim&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Concentration, M&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A_theor</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A_theor&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P_theor</span><span class="p">,</span> <span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P_theor&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fd057b6fb20&gt;
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_17_1.svg" src="../../_images/chap_09_notebook_17_1.svg" /></div>
</div>
<p>The theoretical equation and simulation results are in good agreement. A closer inspection of the two shows a slight discrepancy between the two which is most noticeable earlier in the simulation. This is because the simulation only adjusts the rate every second while the theoretical equation can be thought of as recalculating the rate for infinitely small increments making the theoretical model more accurate.</p>
</div>
<div class="section" id="multistep-stepwise-chemical-kinetics">
<span id="id5"></span><h3>9.1.3 Multistep Stepwise Chemical Kinetics<a class="headerlink" href="#multistep-stepwise-chemical-kinetics" title="Permalink to this headline">¶</a></h3>
<p>If we have a well-established theoretical equation for the above reaction of A <span class="math notranslate nohighlight">\(\rightarrow\)</span> P, why do we need the simulation? With this methodology, we can simulate more complicated reaction mechanisms, such as the multistep reaction below, even if we do not have the theoretical rate law in hand.</p>
<div class="math notranslate nohighlight">
\[ A \underset{k_{r1}}{\stackrel{k_1}{\rightleftharpoons}} I \]</div>
<div class="math notranslate nohighlight">
\[ I + B \underset{k_{r2}}{\stackrel{k_2}{\rightleftharpoons}} P \]</div>
<p>In this reaction, starting material A converts to intermediate I in the first step followed by starting material B combining with I to form the product P. Both of these steps are reversible, so there are four rate constants. The code and output of the simulation are below. Unlike the previous simulation, the simulation below appends values to lists (e.g., <code class="docutils literal notranslate"><span class="pre">A_conc</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A_conc</span><span class="p">,</span> <span class="n">B_conc</span><span class="p">,</span> <span class="n">I_conc</span><span class="p">,</span> <span class="n">P_conc</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
<span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>  <span class="c1"># initial conc, M</span>
<span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">kr2</span> <span class="o">=</span> <span class="mf">0.091</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.01</span> <span class="c1"># rate const</span>
<span class="n">length</span> <span class="o">=</span> <span class="mi">200</span>

<span class="c1"># the simulation</span>
<span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="n">A_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">I_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">B_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
    <span class="n">P_conc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
    <span class="c1"># recalculate rates</span>
    <span class="n">rate_1</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">A</span>
    <span class="n">rate_r1</span> <span class="o">=</span> <span class="n">kr1</span> <span class="o">*</span> <span class="n">I</span>
    <span class="n">rate_2</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span> <span class="o">*</span> <span class="n">I</span>
    <span class="n">rate_r2</span> <span class="o">=</span> <span class="n">kr2</span> <span class="o">*</span> <span class="n">P</span>
    <span class="c1">#recalculate concentrations after next time increment</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">-</span> <span class="n">rate_1</span> <span class="o">+</span> <span class="n">rate_r1</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">I</span> <span class="o">+</span> <span class="n">rate_1</span> <span class="o">-</span> <span class="n">rate_2</span> <span class="o">-</span> <span class="n">rate_r1</span> <span class="o">+</span> <span class="n">rate_r2</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">rate_2</span> <span class="o">+</span> <span class="n">rate_r2</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="n">rate_2</span> <span class="o">-</span> <span class="n">rate_r2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">A_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">I_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;I&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">B_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">P_conc</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Concentration, M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fd057bacd60&gt;
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_21_1.svg" src="../../_images/chap_09_notebook_21_1.svg" /></div>
</div>
<p>A word of caution regarding the above simulations: if the rate constants are increased enough, oscillating behavior and negative concentrations will be observed… the latter of which is clearly wrong. This is because the simulation fails to recalculation the rates fast enough for the simulation, but this can be remedied by decreasing the step size.</p>
</div>
<div class="section" id="chemical-kinetics-and-odeint">
<span id="id6"></span><h3>9.1.4 Chemical Kinetics and ODEINT<a class="headerlink" href="#chemical-kinetics-and-odeint" title="Permalink to this headline">¶</a></h3>
<p>Another approach to performing the above kinetic simulations is to integrate the differential equations. For an introduction to integrating differential equations, see <a class="reference internal" href="../chapter_08/chap_08_notebook.html#id19"><span class="std std-ref">section 8.4.4</span></a>. Below we will simulate a two step reaction where the first step is reversible. Because the following are the elementary steps, the rate equations can be inferred from the reaction stoichiometry.</p>
<div class="math notranslate nohighlight">
\[ A \underset{k_{r1}}{\stackrel{k_1}{\rightleftharpoons}} B \stackrel{k_2}\rightarrow P\]</div>
<p>The three differential equations tracking the concentrations of A, B, and P are shown below where <span class="math notranslate nohighlight">\(k_1\)</span> and <span class="math notranslate nohighlight">\(k_{r1}\)</span> are the forward and reverse rate constants, respectively, for the first step and <span class="math notranslate nohighlight">\(k_2\)</span> is the rate constant for the second step.</p>
<div class="math notranslate nohighlight">
\[ \frac{d[A]}{dt} = k_1[A] + k_{r1}[B] \]</div>
<div class="math notranslate nohighlight">
\[ \frac{d[B]}{dt} = k_1[A] + k_2[B] - k_{r1}[B]\]</div>
<div class="math notranslate nohighlight">
\[ \frac{d[P]}{dt} = k_2[B] \]</div>
<p>As is done in <a class="reference internal" href="../chapter_08/chap_08_notebook.html#id19"><span class="std std-ref">section 8.4.4</span></a>, a Python function is created containing the differential equations, but in contrast to chapter 8, the differential equation for d[P]/dt is also included in the Python function instead  of calculating [P] after the integration.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">k1</span><span class="p">,</span> <span class="n">kr1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.3</span>
<span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">P0</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rates</span><span class="p">(</span><span class="n">conc</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">conc</span>
    <span class="n">dAdt</span> <span class="o">=</span> <span class="o">-</span><span class="n">k1</span> <span class="o">*</span> <span class="n">A</span> <span class="o">+</span> <span class="n">kr1</span> <span class="o">*</span> <span class="n">B</span>
    <span class="n">dBdt</span> <span class="o">=</span> <span class="n">k1</span> <span class="o">*</span> <span class="n">A</span> <span class="o">-</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span> <span class="o">-</span> <span class="n">kr1</span> <span class="o">*</span> <span class="n">B</span>
    <span class="n">dPdt</span> <span class="o">=</span> <span class="n">k2</span> <span class="o">*</span> <span class="n">B</span>
    
    <span class="k">return</span> <span class="n">dAdt</span><span class="p">,</span> <span class="n">dBdt</span><span class="p">,</span> <span class="n">dPdt</span>
</pre></div>
</div>
</div>
</div>
<p>Because the <code class="docutils literal notranslate"><span class="pre">odeint()</span></code> function only takes the initial concentration (<code class="docutils literal notranslate"><span class="pre">A0</span></code>, <code class="docutils literal notranslate"><span class="pre">B0</span></code>, and <code class="docutils literal notranslate"><span class="pre">P0</span></code>) as a single argument, they need to be placed in a tuple.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A_t</span><span class="p">,</span> <span class="n">B_t</span><span class="p">,</span> <span class="n">P_t</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">rates</span><span class="p">,</span> <span class="p">(</span><span class="n">A0</span><span class="p">,</span> <span class="n">B0</span><span class="p">,</span> <span class="n">P0</span><span class="p">),</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A_t</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">B_t</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P_t</span><span class="p">,</span> <span class="s1">&#39;-.&#39;</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;P&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;[X], M&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fd057c84eb0&gt;
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_27_1.svg" src="../../_images/chap_09_notebook_27_1.svg" /></div>
</div>
</div>
</div>
<div class="section" id="stochastic-simulations">
<span id="id7"></span><h2>9.2 Stochastic Simulations<a class="headerlink" href="#stochastic-simulations" title="Permalink to this headline">¶</a></h2>
<p>Unlike the deterministic simulations above, if the same code for a stochastic simulation is run multiple times, the results will vary at least slightly, though the overall patterns should be similar. This is because the outcome of stochastic simulations is determined by (pseudo)random number generators. It is as if the results of the simulation are dictated by the flip of a coin or roll of a die. This analogy is so good that rolling dice repeatedly can simulate radioactive decay kinetics among other things. We will use NumPy’s <code class="docutils literal notranslate"><span class="pre">random</span></code> module to generate random values for the simulations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a random component to some of the following code, so exact results may vary.</p>
</div>
<div class="section" id="radioactive-decay">
<span id="id8"></span><h3>9.2.1 Radioactive Decay<a class="headerlink" href="#radioactive-decay" title="Permalink to this headline">¶</a></h3>
<p>Radioactive decay is a random process, so logically it can be simulated as such. Every radioactive atom has a fixed probability of decaying each second just like a die has a fixed probability of rolling a one. A <code class="docutils literal notranslate"><span class="pre">for</span></code> loop is used for each second or step of the simulation, and a random number generator is used in each step to decide how many atoms decay. The <code class="docutils literal notranslate"><span class="pre">np.random.binomial()</span></code> function is used here to generate a series of zeros and ones with a set probability of generating a one. In this simulation, a one signifies a decaying atom. These decayed atoms are tallied and subtracted from the current number of remaining atoms, and this value is recorded.</p>
<div class="cell tag_remove-input docutils container">
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">starting_atoms</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">length</span> <span class="o">=</span> <span class="mi">10000</span>  <span class="c1"># length of simulation</span>
<span class="n">num_atoms</span> <span class="o">=</span> <span class="n">starting_atoms</span>
<span class="n">record</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
    <span class="n">record</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_atoms</span><span class="p">)</span>
    <span class="c1"># &quot;rolls&quot; dice and tallies up number of zeros</span>
    <span class="n">rolls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">binomial</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_atoms</span><span class="p">)</span>
    <span class="n">decayed_count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rolls</span><span class="p">)</span>
    <span class="c1"># deduct decayed nuclei from the total</span>
    <span class="n">num_atoms</span> <span class="o">-=</span> <span class="n">decayed_count</span>
<span class="n">record</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The results stored are in an array called <code class="docutils literal notranslate"><span class="pre">record</span></code> which can be plotted along with the first-order integrated rate law to see how the two compare. Being that there is a 1/1000 probability in the above simulation of each atom generating a one (decay), the rate constant (<span class="math notranslate nohighlight">\(k\)</span>) is 0.001 s<span class="math notranslate nohighlight">\(^{-1}\)</span>. For ease of viewing, only twenty data points from the simulation are plotting below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot of simulation</span>
<span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">record</span><span class="p">[::</span><span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulation Results&#39;</span><span class="p">)</span>
<span class="c1"># plot of theoretical rate law</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">starting_atoms</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">t</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Theoretical Model&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Atoms Remaining&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Atoms Remaining&#39;)
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_32_1.svg" src="../../_images/chap_09_notebook_32_1.svg" /></div>
</div>
<p>The simulation and theoretical model are in good but not perfect agreement. The deviation is a result of the simulation using random numbers and only simulating a relatively small number of molecules. If this simulation were run with increasingly larger number of molecules, the results are expected to converge on the theoretical prediction.</p>
</div>
<div class="section" id="confidence-intervals">
<span id="id9"></span><h3>9.2.2 Confidence Intervals<a class="headerlink" href="#confidence-intervals" title="Permalink to this headline">¶</a></h3>
<p>Uncertainty is a part of all data, and uncertainty around a repeatedly measured and calculated value is sometimes represented in the form of a 95% confidence interval (CI). This is the interval around the mean that has a 95% chance of containing the true value. Another way of describing 95% CI is that if we were to repeatedly collect a data set and calculate the 95% CI, the true value should be, statistically speaking, inside the confidence interval 95% of the time. Performing these experiments would be tedious, but this can be simulated in Python relatively easily.</p>
<p>The equation for calculating the 95% CI is shown below where <span class="math notranslate nohighlight">\(\bar{x}\)</span> is the average value in a set of repeated measurements, s is the standard deviation (corrected), t is the statistical t value from a table, and N is the degrees of freedom. For 20 samples per set, t = 2.09 and N = 19.</p>
<div class="math notranslate nohighlight">
\[ 95\%CI = \bar{x} \pm \frac{ts}{\sqrt{N}} \]</div>
<p>We can simulated the data collection by picking a true value and generating twenty samples by adding random error to twenty copies of the true value. Using the simulated data set, the 95% CI can be calculated, and we can test whether or not the true value is inside the CI. If we repeated this procedure numerous times recording the success or failure of the true value being inside the CI, we can calculate the success rate as demonstrated below.</p>
<div class="cell tag_remove-input docutils container">
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">trials</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">t</span> <span class="o">=</span> <span class="mf">2.09</span>
<span class="n">true</span> <span class="o">=</span> <span class="mf">6.2</span>  <span class="c1"># true value</span>
<span class="c1"># list contain a one for each time true inside 95% CI</span>
<span class="n">in_interval</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="c1"># create synthetic data</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">true</span> <span class="o">+</span> <span class="p">(</span><span class="n">error</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    
    <span class="c1"># calculate the 95% CI</span>
    <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">CI_95</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">-</span> <span class="n">CI_95</span>
    <span class="n">upper</span> <span class="o">=</span> <span class="n">avg</span> <span class="o">+</span> <span class="n">CI_95</span>
    
    <span class="c1"># determine if true values is inside 95% CI</span>
    <span class="k">if</span> <span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">true</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">:</span>
        <span class="n">in_interval</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">in_interval</span><span class="p">)</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>94.783
</pre></div>
</div>
</div>
</div>
<p>The above simulation finds that almost 95% of the time, the true value is inside the 95% CI which is pretty close to what we expected. If this simulation is repeated, you will likely observe that the values are very often slightly below the expected 95%. This is the result of smaller data sets and should be closer to the theoretical value with increasing data set size.</p>
</div>
<div class="section" id="random-flight-polymer">
<span id="id10"></span><h3>9.2.3 Random Flight Polymer<a class="headerlink" href="#random-flight-polymer" title="Permalink to this headline">¶</a></h3>
<p>Polymers are long chains of repeating units called monomers. These chains can easily extend for thousands of monomers and wind around in 3D space in seemingly random fashions. A single polymer chain can be made of a single type of monomer or multiple types and can be of varying lengths, but for the following polymer simulation, we will work with polymers of a fixed number of monomers and ignore the monomer types.</p>
<p>One model for polymer conformation is a <em>random flight polymer</em> which assumes that the conformation of the polymer is entirely random. We can simulate a random flight polymer through a <em>random walk</em> by making each subsequent segment of polymer extend in a random direction and distance. For simplicity, we will simulate the polymer in only two dimensions, but this simulation can be expanded to a third dimension. The random element of the simulation is provided by a NumPy random number generator which generates a random length and direction for each new segment.</p>
<p>The general procedure for the following simulation is to start the polymer chain at coordinate (0, 0), and for each new segment, add a random value to the x-coordinate of the previous polymer end and another random value to the y-coordinate. Each new coordinate is then appended to a list of coordinates (<code class="docutils literal notranslate"><span class="pre">coords</span></code>) for analysis and visualization. This simulation is coded below. The random values are floats from -1 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 1. NumPy does not provide a function for generating this range, so we can modify the 0 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 1 range from the <code class="docutils literal notranslate"><span class="pre">np.random.rand()</span></code> function by subtracting 0.5 and multiplying by 2.</p>
<div class="cell tag_remove-input docutils container">
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">segments</span> <span class="o">=</span> <span class="mi">3000</span>
<span class="n">coords</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
    
<span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Position(x), au&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Position(y), au&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Position(y), au&#39;)
</pre></div>
</div>
<img alt="../../_images/chap_09_notebook_42_1.svg" src="../../_images/chap_09_notebook_42_1.svg" /></div>
</div>
<p>The results of the simulation show a polymer strand winding around in an apparently random fashion. If we rerun the above simulation, a different looking polymer conformation will be generated.</p>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p>Downey, Allen Modeling and Simulation in Python. Book in progress. <a class="reference external" href="https://github.com/AllenDowney/ModSimPy">https://github.com/AllenDowney/ModSimPy</a> (free resource)</p></li>
<li><p>Weiss, C. J. Introduction to Stochastic Simulations for Chemical and Physical Processes: Principles and Applications. J. Chem. Educ. 2017, 94 (12), 1904–1910. <a class="reference external" href="https://doi.org/10.1021/acs.jchemed.7b00395">https://doi.org/10.1021/acs.jchemed.7b00395</a></p></li>
<li><p>For examples of chemical kinetics scenarios to model, see: Bentenitis, N. A Convenient Tool for the Stochastic Simulation of Reaction Mechanisms. J. Chem. Educ. 2008, 85 (8), 1146−1150. <a class="reference external" href="https://doi.org/10.1021/ed085p1146">https://doi.org/10.1021/ed085p1146</a></p></li>
</ol>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Complete the following exercises in a Jupyter notebook. Any data file(s) refered to in the problems can be found in the <strong>data</strong> folder in the same directory as this chapter’s Jupyter notebook.</p>
<ol>
<li><p>Using <code class="docutils literal notranslate"><span class="pre">scipy.integrate.odeint()</span></code> and a differential equation, plot the concentration of starting material A with respect to time for a third-order reaction.</p></li>
<li><p>Create a simulation of the following single-step reaction and overlay it with the appropriate integrated rate law. The rate constant is 0.28 M<span class="math notranslate nohighlight">\(^{-1}\)</span>s<span class="math notranslate nohighlight">\(^{-1}\)</span>. Feel free to start with code from this chapter and modify it as needed.</p>
<div class="math notranslate nohighlight">
\[ 2A \rightarrow P \]</div>
</li>
<li><p>Plot the concentrations of A, B, C, and P with respect to time for the following three-step, non-reversible mechanism. The initial concentrations and rate constants are in the table below.</p>
<div class="math notranslate nohighlight">
\[ A \rightarrow B \rightarrow C \rightarrow P  \]</div>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Step</p></th>
<th class="text-align:center head"><p>Specie</p></th>
<th class="text-align:center head"><p>[Specie]<span class="math notranslate nohighlight">\(_0\)</span>, M</p></th>
<th class="text-align:center head"><p>Rate Constant, s<span class="math notranslate nohighlight">\(^{-1}\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1</p></td>
<td class="text-align:center"><p>A</p></td>
<td class="text-align:center"><p>1.50</p></td>
<td class="text-align:center"><p>0.8</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2</p></td>
<td class="text-align:center"><p>B</p></td>
<td class="text-align:center"><p>0.00</p></td>
<td class="text-align:center"><p>0.4</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>3</p></td>
<td class="text-align:center"><p>C</p></td>
<td class="text-align:center"><p>0.00</p></td>
<td class="text-align:center"><p>0.3</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>–</p></td>
<td class="text-align:center"><p>P</p></td>
<td class="text-align:center"><p>0.00</p></td>
<td class="text-align:center"><p>–</p></td>
</tr>
</tbody>
</table>
</li>
<li><p>Simulate the following chemical equilibrium where the forward rate is described by Rate<span class="math notranslate nohighlight">\(_f\)</span> = (1.3 × 10<span class="math notranslate nohighlight">\(^{-2}\)</span> M<span class="math notranslate nohighlight">\(^{-1}\)</span>s<span class="math notranslate nohighlight">\(^{-1}\)</span>)[A]<span class="math notranslate nohighlight">\(^2\)</span> and the reverse rate is described by Rate<span class="math notranslate nohighlight">\(_r\)</span> = (6.2 × 10<span class="math notranslate nohighlight">\(^{-3}\)</span> s<span class="math notranslate nohighlight">\(^{-1}\)</span>)[B].</p>
<div class="math notranslate nohighlight">
\[ 2A \underset{k_r}{\stackrel{k_f}{\rightleftharpoons}} B \]</div>
<p>Use a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop to simulate each second of reaction by calculating the rates and increasing/decreasing each concentration appropriately. Record the concentrations in lists and plot the results. Start with 2.20 M of A and 1.72 M B and run the simulation for at least 200 seconds. Notice that the rates are in M/s.</p>
</li>
<li><p>In <a class="reference internal" href="#id5"><span class="std std-ref">section 9.1.3</span></a>, a two-step, reversible reaction is simulated. If the rate constant k<span class="math notranslate nohighlight">\(_{r1}\)</span> is decreased to 0.001 s<span class="math notranslate nohighlight">\(^{-1}\)</span>, what effect on the reaction do you anticipate? Simulate this to see if your prediction is correct.</p></li>
<li><p>Simulate two competing, first-order reactions of starting material A forming product P<span class="math notranslate nohighlight">\(_1\)</span> and P<span class="math notranslate nohighlight">\(_2\)</span> and plot the resulting concentrations of both products versus time. Use k<span class="math notranslate nohighlight">\(_1\)</span> = 0.02 M/s and k<span class="math notranslate nohighlight">\(_2\)</span> = 0.04 M/s and start with 2.00 M A. What do you predict the plot of concentration versus time to look like and the ratio of products to be? Does your simulation agree?</p></li>
</ol>
<div class="math notranslate nohighlight">
\[ P_1 \stackrel{k_1}{\leftarrow} A \stackrel{k_2}\rightarrow P_2 \]</div>
<ol>
<li><p>Polymers that consist of two or more different monomers are known as copolymers. Simulate an addition copolymer consisting of two monomers: ethylene (28.06 g/mol) and styrene (104.16 g/mol) with a fixed length of a thousand units. Given the molecular weights of the two monomers above, calculate the weights for a thousand simulated polymer strands and generate a histograms of the frequency versus weight. Hint: try using the <code class="docutils literal notranslate"><span class="pre">np.random.binomial()</span></code> function with <code class="docutils literal notranslate"><span class="pre">p=0.5</span></code> and treat a zero as one monomer and a one is   the other.</p></li>
<li><p>Block copolymers are polymers where multiple monomer types are clustered along the polymer chain instead of being randomly dispersed. These clusters are called blocks which may be of random lengths as the polymer switches between monomer types. An example is shown below.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>-A-A-A-A-A-A-A-B-B-B-B-B-B-A-A-A-A-B-B-B-A-A-A-A-A-
</pre></div>
</div>
<p>Simulate a block copolymer consisting of two monomers with a total length of a hundred monomer units.</p>
<p>Hint: Append monomers (0 or 1) to a list inside a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, and use a function from <code class="docutils literal notranslate"><span class="pre">np.random.binomial()</span></code> to decide when to toggle between monomers types. Use <code class="docutils literal notranslate"><span class="pre">mono</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">mono</span></code> to make the switch.</p>
</li>
<li><p>The random flight polymer simulation presented in section 9.2.3 uses a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop. As discussed in chapter 4, one of the virtues of NumPy is that it often avoids the computationally inefficient <code class="docutils literal notranslate"><span class="pre">for</span></code> loops. Below is the same simulation written in a single line of code leveraging the power of NumPy arrays. Briefly explain what it is doing and why it works.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">loc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span><span class="mi">2</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Proteins are nature polymers consisting of twenty common monomers called amino acids. Simulate a random protein strand of a thousand units long using the <code class="docutils literal notranslate"><span class="pre">np.random.randint()</span></code> function and a Python dictionary or list containing the single letter amino acid codes.</p></li>
<li><p>Confidence intervals</p>
<p>a) Convert the code for calculating a 95% confidence interval in <a class="reference internal" href="#id9"><span class="std std-ref">section 9.2.2</span></a> to a Python function that accepts the number of samples as the one argument and returns the percentage of the time the true value is inside the confidence interval. You will need to look up t values and generate a dictionary that converts degrees of freedom (N) to t values.</p>
<p>b) Using a <code class="docutils literal notranslate"><span class="pre">for</span></code> loop, calculate the percentage of the time the true value is in the 95% confidence interval for each of the sample sizes in the above dictionary and plot the results. Describe the trend.</p>
</li>
<li><p>Simulate the diffusion of molecules along a single axis. Start all molecules at zero, and for each step of the simulation, add a random number, positive or negative, to each value in the array. Plot the results in a histogram.</p></li>
<li><p>Using the function from <a class="reference internal" href="#id3"><span class="std std-ref">section 9.1.1</span></a>, simulate the splitting pattern for the tertiary proton in isopropyl alcohol ((CH<span class="math notranslate nohighlight">\(_3\)</span>)<span class="math notranslate nohighlight">\(_2\)</span>CHOH). In CDCl<span class="math notranslate nohighlight">\(_3\)</span>, this proton is observed at 3.82 ppm with a coupling constant of 6 Hz. Assume no coupling with the hydroxyl proton is observed.</p></li>
<li><p>The law of large numbers indicates that as the number of trials increases, the observed average should overall converge on the statistical average. For example, when rolling a six-sided die, all numbers are equally probable to land up, so if we roll a number of dice, the average of all the numbers is expected to be around 3.5 (i.e., (1 + 2 + 3 + 4 + 5 + 6)/6 = 3.5). Using the <code class="docutils literal notranslate"><span class="pre">np.random.randint()</span></code> function, simulate the rolling of between two and five thousand, six-sided dice and plot the resulting average number versus the number of dice rolled. Include at least a hundred data points in your plot and label your axes.</p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks/chapter_09"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../chapter_08/chap_08_notebook.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Chapter 8: Mathematics</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../chapter_10/chap_10_notebook.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 10: Plotting with Seaborn</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Charles J. Weiss<br/>
    
        &copy; Copyright 2021-2022.<br/>
      <div class="extra_footer">
        Scientific Computing for Chemists with Python is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/](https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
      </div>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>